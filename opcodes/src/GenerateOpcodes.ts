import * as path from "path";
import * as fs from "fs";
import {toHex} from "z80-test/dist";

function handle_rst(output: string[], rst: number): void {
    output.push("    z80.tStateCount += 1;");
    output.push("    z80.pushWord(z80.regs.pc);");
    output.push("    z80.regs.pc = 0x" + toHex(rst, 4)+ ";");
    output.push("    z80.regs.memptr = z80.regs.pc;");
}

function processFile(pathname: string): void {
    const output: string[] = [];
    output.push("");
    output.push("// The content of this switch is auto-generated by GenerateOpcodes.ts.");
    output.push("");

    const template = fs.readFileSync("src/Decode.template.ts", "utf-8");

    fs.readFileSync(pathname, "utf-8").split(/\r?\n/).forEach((line: string) => {
        line = line.trim();
        if (line.length === 0 || line.startsWith("#")) {
            // Comment or empty line.
            return;
        }

        const fields = line.split(/\s+/);
        const numberString = fields.length >= 1 ? fields[0] : undefined;
        const opcode = fields.length >= 2 ? fields[1] : undefined;
        const params = fields.length >= 3 ? fields[2] : undefined;
        const extra = fields.length >= 4 ? fields[3] : undefined;
        if (fields.length > 4) {
            throw new Error("Invalid opcode line: " + line);
        }

        if (numberString === undefined || numberString.length == 0 || !numberString.startsWith("0x")) {
            throw new Error("Invalid number: " + line);
        }

        const number = parseInt(numberString, 16);

        output.push("case 0x" + toHex(number, 2) + ": { // " + line);

        if (opcode === undefined) {
            output.push("    // Undefined opcode.");
        } else {
            switch (opcode) {
                case "LD": {
                    if (params === undefined) {
                        throw new Error("LD requires params: " + line);
                    }
                    const locs = params.split(",");
                    if (locs.length !== 2) {
                        throw new Error("LD requires two params: " + line);
                    }
                    const [dest, src] = locs;
                    if (dest.length === 1 && src.length === 1) {
                        if (dest !== src) {
                            output.push("    z80.regs." + dest.toLowerCase() + " = z80.regs." + src.toLowerCase() + ";");
                        }
                    } else {
                        console.log("Unhandled LD: " + line);
                    }

                    break;
                }

                case "RST":
                    if (params === undefined) {
                        throw new Error("RST requires params: " + line);
                    }
                    handle_rst(output, parseInt(params, 16));
                    break;

                default:
                    console.log("Unhandled opcode: " + line);
                    break;
            }
        }

        output.push("    break;");
        output.push("}");
        output.push("");
    });

    const replacement = output.map((line) => line.length === 0 ? line : "        " + line).join("\n");
    const finalCode = template.replace("// DECODE", replacement);

    fs.writeFileSync("src/Decode.ts", finalCode);
}

function generateOpcodes(): void {
    const opcodesDir = path.join(__dirname, "..");
    const basePathname = path.join(opcodesDir, "opcodes_base.dat");

    processFile(basePathname);
}

generateOpcodes();
