// Do not modify. This file is generated by GenerateOpcodes.ts.

import {Z80} from "./Z80";
import {toHex, inc8, inc16, dec8, dec16, add8, add16, sub8, sub16, word, hi, lo, Flag, signedByte} from "z80-test/dist";

const halfCarryAddTable = [0, Flag.H, Flag.H, Flag.H, 0, 0, 0, Flag.H];
const halfCarrySubTable = [0, 0, Flag.H, 0, Flag.H, 0, Flag.H, Flag.H];
const overflowAddTable = [0, 0, 0, Flag.V, Flag.V, 0, 0, 0];
const overflowSubTable = [0, Flag.V, 0, 0, 0, 0, Flag.V, 0];

function fetchInstruction(z80: Z80): number {
    z80.incTStateCount(4);
    const inst = z80.readByteInternal(z80.regs.pc);
    z80.regs.pc = (z80.regs.pc + 1) & 0xFFFF;
    z80.regs.r = (z80.regs.r + 1) & 0xFF;

    return inst;
}

function decodeCB(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x00: { // rlc b
            break;
        }

        case 0x01: { // rlc c
            break;
        }

        case 0x02: { // rlc d
            break;
        }

        case 0x03: { // rlc e
            break;
        }

        case 0x04: { // rlc h
            break;
        }

        case 0x05: { // rlc l
            break;
        }

        case 0x06: { // rlc (hl)
            break;
        }

        case 0x07: { // rlc a
            break;
        }

        case 0x08: { // rrc b
            break;
        }

        case 0x09: { // rrc c
            break;
        }

        case 0x0A: { // rrc d
            break;
        }

        case 0x0B: { // rrc e
            break;
        }

        case 0x0C: { // rrc h
            break;
        }

        case 0x0D: { // rrc l
            break;
        }

        case 0x0E: { // rrc (hl)
            break;
        }

        case 0x0F: { // rrc a
            break;
        }

        case 0x10: { // rl b
            break;
        }

        case 0x11: { // rl c
            break;
        }

        case 0x12: { // rl d
            break;
        }

        case 0x13: { // rl e
            break;
        }

        case 0x14: { // rl h
            break;
        }

        case 0x15: { // rl l
            break;
        }

        case 0x16: { // rl (hl)
            break;
        }

        case 0x17: { // rl a
            break;
        }

        case 0x18: { // rr b
            break;
        }

        case 0x19: { // rr c
            break;
        }

        case 0x1A: { // rr d
            break;
        }

        case 0x1B: { // rr e
            break;
        }

        case 0x1C: { // rr h
            break;
        }

        case 0x1D: { // rr l
            break;
        }

        case 0x1E: { // rr (hl)
            break;
        }

        case 0x1F: { // rr a
            break;
        }

        case 0x20: { // sla b
            break;
        }

        case 0x21: { // sla c
            break;
        }

        case 0x22: { // sla d
            break;
        }

        case 0x23: { // sla e
            break;
        }

        case 0x24: { // sla h
            break;
        }

        case 0x25: { // sla l
            break;
        }

        case 0x26: { // sla (hl)
            break;
        }

        case 0x27: { // sla a
            break;
        }

        case 0x28: { // sra b
            break;
        }

        case 0x29: { // sra c
            break;
        }

        case 0x2A: { // sra d
            break;
        }

        case 0x2B: { // sra e
            break;
        }

        case 0x2C: { // sra h
            break;
        }

        case 0x2D: { // sra l
            break;
        }

        case 0x2E: { // sra (hl)
            break;
        }

        case 0x2F: { // sra a
            break;
        }

        case 0x30: { // sll b
            break;
        }

        case 0x31: { // sll c
            break;
        }

        case 0x32: { // sll d
            break;
        }

        case 0x33: { // sll e
            break;
        }

        case 0x34: { // sll h
            break;
        }

        case 0x35: { // sll l
            break;
        }

        case 0x36: { // sll (hl)
            break;
        }

        case 0x37: { // sll a
            break;
        }

        case 0x38: { // srl b
            break;
        }

        case 0x39: { // srl c
            break;
        }

        case 0x3A: { // srl d
            break;
        }

        case 0x3B: { // srl e
            break;
        }

        case 0x3C: { // srl h
            break;
        }

        case 0x3D: { // srl l
            break;
        }

        case 0x3E: { // srl (hl)
            break;
        }

        case 0x3F: { // srl a
            break;
        }

        case 0x40: { // bit 0,b
            break;
        }

        case 0x41: { // bit 0,c
            break;
        }

        case 0x42: { // bit 0,d
            break;
        }

        case 0x43: { // bit 0,e
            break;
        }

        case 0x44: { // bit 0,h
            break;
        }

        case 0x45: { // bit 0,l
            break;
        }

        case 0x46: { // bit 0,(hl)
            break;
        }

        case 0x47: { // bit 0,a
            break;
        }

        case 0x48: { // bit 1,b
            break;
        }

        case 0x49: { // bit 1,c
            break;
        }

        case 0x4A: { // bit 1,d
            break;
        }

        case 0x4B: { // bit 1,e
            break;
        }

        case 0x4C: { // bit 1,h
            break;
        }

        case 0x4D: { // bit 1,l
            break;
        }

        case 0x4E: { // bit 1,(hl)
            break;
        }

        case 0x4F: { // bit 1,a
            break;
        }

        case 0x50: { // bit 2,b
            break;
        }

        case 0x51: { // bit 2,c
            break;
        }

        case 0x52: { // bit 2,d
            break;
        }

        case 0x53: { // bit 2,e
            break;
        }

        case 0x54: { // bit 2,h
            break;
        }

        case 0x55: { // bit 2,l
            break;
        }

        case 0x56: { // bit 2,(hl)
            break;
        }

        case 0x57: { // bit 2,a
            break;
        }

        case 0x58: { // bit 3,b
            break;
        }

        case 0x59: { // bit 3,c
            break;
        }

        case 0x5A: { // bit 3,d
            break;
        }

        case 0x5B: { // bit 3,e
            break;
        }

        case 0x5C: { // bit 3,h
            break;
        }

        case 0x5D: { // bit 3,l
            break;
        }

        case 0x5E: { // bit 3,(hl)
            break;
        }

        case 0x5F: { // bit 3,a
            break;
        }

        case 0x60: { // bit 4,b
            break;
        }

        case 0x61: { // bit 4,c
            break;
        }

        case 0x62: { // bit 4,d
            break;
        }

        case 0x63: { // bit 4,e
            break;
        }

        case 0x64: { // bit 4,h
            break;
        }

        case 0x65: { // bit 4,l
            break;
        }

        case 0x66: { // bit 4,(hl)
            break;
        }

        case 0x67: { // bit 4,a
            break;
        }

        case 0x68: { // bit 5,b
            break;
        }

        case 0x69: { // bit 5,c
            break;
        }

        case 0x6A: { // bit 5,d
            break;
        }

        case 0x6B: { // bit 5,e
            break;
        }

        case 0x6C: { // bit 5,h
            break;
        }

        case 0x6D: { // bit 5,l
            break;
        }

        case 0x6E: { // bit 5,(hl)
            break;
        }

        case 0x6F: { // bit 5,a
            break;
        }

        case 0x70: { // bit 6,b
            break;
        }

        case 0x71: { // bit 6,c
            break;
        }

        case 0x72: { // bit 6,d
            break;
        }

        case 0x73: { // bit 6,e
            break;
        }

        case 0x74: { // bit 6,h
            break;
        }

        case 0x75: { // bit 6,l
            break;
        }

        case 0x76: { // bit 6,(hl)
            break;
        }

        case 0x77: { // bit 6,a
            break;
        }

        case 0x78: { // bit 7,b
            break;
        }

        case 0x79: { // bit 7,c
            break;
        }

        case 0x7A: { // bit 7,d
            break;
        }

        case 0x7B: { // bit 7,e
            break;
        }

        case 0x7C: { // bit 7,h
            break;
        }

        case 0x7D: { // bit 7,l
            break;
        }

        case 0x7E: { // bit 7,(hl)
            break;
        }

        case 0x7F: { // bit 7,a
            break;
        }

        case 0x80: { // res 0,b
            break;
        }

        case 0x81: { // res 0,c
            break;
        }

        case 0x82: { // res 0,d
            break;
        }

        case 0x83: { // res 0,e
            break;
        }

        case 0x84: { // res 0,h
            break;
        }

        case 0x85: { // res 0,l
            break;
        }

        case 0x86: { // res 0,(hl)
            break;
        }

        case 0x87: { // res 0,a
            break;
        }

        case 0x88: { // res 1,b
            break;
        }

        case 0x89: { // res 1,c
            break;
        }

        case 0x8A: { // res 1,d
            break;
        }

        case 0x8B: { // res 1,e
            break;
        }

        case 0x8C: { // res 1,h
            break;
        }

        case 0x8D: { // res 1,l
            break;
        }

        case 0x8E: { // res 1,(hl)
            break;
        }

        case 0x8F: { // res 1,a
            break;
        }

        case 0x90: { // res 2,b
            break;
        }

        case 0x91: { // res 2,c
            break;
        }

        case 0x92: { // res 2,d
            break;
        }

        case 0x93: { // res 2,e
            break;
        }

        case 0x94: { // res 2,h
            break;
        }

        case 0x95: { // res 2,l
            break;
        }

        case 0x96: { // res 2,(hl)
            break;
        }

        case 0x97: { // res 2,a
            break;
        }

        case 0x98: { // res 3,b
            break;
        }

        case 0x99: { // res 3,c
            break;
        }

        case 0x9A: { // res 3,d
            break;
        }

        case 0x9B: { // res 3,e
            break;
        }

        case 0x9C: { // res 3,h
            break;
        }

        case 0x9D: { // res 3,l
            break;
        }

        case 0x9E: { // res 3,(hl)
            break;
        }

        case 0x9F: { // res 3,a
            break;
        }

        case 0xA0: { // res 4,b
            break;
        }

        case 0xA1: { // res 4,c
            break;
        }

        case 0xA2: { // res 4,d
            break;
        }

        case 0xA3: { // res 4,e
            break;
        }

        case 0xA4: { // res 4,h
            break;
        }

        case 0xA5: { // res 4,l
            break;
        }

        case 0xA6: { // res 4,(hl)
            break;
        }

        case 0xA7: { // res 4,a
            break;
        }

        case 0xA8: { // res 5,b
            break;
        }

        case 0xA9: { // res 5,c
            break;
        }

        case 0xAA: { // res 5,d
            break;
        }

        case 0xAB: { // res 5,e
            break;
        }

        case 0xAC: { // res 5,h
            break;
        }

        case 0xAD: { // res 5,l
            break;
        }

        case 0xAE: { // res 5,(hl)
            break;
        }

        case 0xAF: { // res 5,a
            break;
        }

        case 0xB0: { // res 6,b
            break;
        }

        case 0xB1: { // res 6,c
            break;
        }

        case 0xB2: { // res 6,d
            break;
        }

        case 0xB3: { // res 6,e
            break;
        }

        case 0xB4: { // res 6,h
            break;
        }

        case 0xB5: { // res 6,l
            break;
        }

        case 0xB6: { // res 6,(hl)
            break;
        }

        case 0xB7: { // res 6,a
            break;
        }

        case 0xB8: { // res 7,b
            break;
        }

        case 0xB9: { // res 7,c
            break;
        }

        case 0xBA: { // res 7,d
            break;
        }

        case 0xBB: { // res 7,e
            break;
        }

        case 0xBC: { // res 7,h
            break;
        }

        case 0xBD: { // res 7,l
            break;
        }

        case 0xBE: { // res 7,(hl)
            break;
        }

        case 0xBF: { // res 7,a
            break;
        }

        case 0xC0: { // set 0,b
            break;
        }

        case 0xC1: { // set 0,c
            break;
        }

        case 0xC2: { // set 0,d
            break;
        }

        case 0xC3: { // set 0,e
            break;
        }

        case 0xC4: { // set 0,h
            break;
        }

        case 0xC5: { // set 0,l
            break;
        }

        case 0xC6: { // set 0,(hl)
            break;
        }

        case 0xC7: { // set 0,a
            break;
        }

        case 0xC8: { // set 1,b
            break;
        }

        case 0xC9: { // set 1,c
            break;
        }

        case 0xCA: { // set 1,d
            break;
        }

        case 0xCB: { // set 1,e
            break;
        }

        case 0xCC: { // set 1,h
            break;
        }

        case 0xCD: { // set 1,l
            break;
        }

        case 0xCE: { // set 1,(hl)
            break;
        }

        case 0xCF: { // set 1,a
            break;
        }

        case 0xD0: { // set 2,b
            break;
        }

        case 0xD1: { // set 2,c
            break;
        }

        case 0xD2: { // set 2,d
            break;
        }

        case 0xD3: { // set 2,e
            break;
        }

        case 0xD4: { // set 2,h
            break;
        }

        case 0xD5: { // set 2,l
            break;
        }

        case 0xD6: { // set 2,(hl)
            break;
        }

        case 0xD7: { // set 2,a
            break;
        }

        case 0xD8: { // set 3,b
            break;
        }

        case 0xD9: { // set 3,c
            break;
        }

        case 0xDA: { // set 3,d
            break;
        }

        case 0xDB: { // set 3,e
            break;
        }

        case 0xDC: { // set 3,h
            break;
        }

        case 0xDD: { // set 3,l
            break;
        }

        case 0xDE: { // set 3,(hl)
            break;
        }

        case 0xDF: { // set 3,a
            break;
        }

        case 0xE0: { // set 4,b
            break;
        }

        case 0xE1: { // set 4,c
            break;
        }

        case 0xE2: { // set 4,d
            break;
        }

        case 0xE3: { // set 4,e
            break;
        }

        case 0xE4: { // set 4,h
            break;
        }

        case 0xE5: { // set 4,l
            break;
        }

        case 0xE6: { // set 4,(hl)
            break;
        }

        case 0xE7: { // set 4,a
            break;
        }

        case 0xE8: { // set 5,b
            break;
        }

        case 0xE9: { // set 5,c
            break;
        }

        case 0xEA: { // set 5,d
            break;
        }

        case 0xEB: { // set 5,e
            break;
        }

        case 0xEC: { // set 5,h
            break;
        }

        case 0xED: { // set 5,l
            break;
        }

        case 0xEE: { // set 5,(hl)
            break;
        }

        case 0xEF: { // set 5,a
            break;
        }

        case 0xF0: { // set 6,b
            break;
        }

        case 0xF1: { // set 6,c
            break;
        }

        case 0xF2: { // set 6,d
            break;
        }

        case 0xF3: { // set 6,e
            break;
        }

        case 0xF4: { // set 6,h
            break;
        }

        case 0xF5: { // set 6,l
            break;
        }

        case 0xF6: { // set 6,(hl)
            break;
        }

        case 0xF7: { // set 6,a
            break;
        }

        case 0xF8: { // set 7,b
            break;
        }

        case 0xF9: { // set 7,c
            break;
        }

        case 0xFA: { // set 7,d
            break;
        }

        case 0xFB: { // set 7,e
            break;
        }

        case 0xFC: { // set 7,h
            break;
        }

        case 0xFD: { // set 7,l
            break;
        }

        case 0xFE: { // set 7,(hl)
            break;
        }

        case 0xFF: { // set 7,a
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeDD(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x09: { // add ix,bc
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.bc;
            let result = z80.regs.ix + value;
            const lookup = (((z80.regs.ix & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.ix);
            z80.regs.ix = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x19: { // add ix,de
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.de;
            let result = z80.regs.ix + value;
            const lookup = (((z80.regs.ix & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.ix);
            z80.regs.ix = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x21: { // ld ix,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.ix = value;
            break;
        }

        case 0x22: { // ld (nnnn),ix
            let value: number;
            value = z80.regs.ix;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x23: { // inc ix
            break;
        }

        case 0x24: { // inc ixh
            break;
        }

        case 0x25: { // dec ixh
            break;
        }

        case 0x26: { // ld ixh,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.ixh = value;
            break;
        }

        case 0x29: { // add ix,ix
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.ix;
            let result = z80.regs.ix + value;
            const lookup = (((z80.regs.ix & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.ix);
            z80.regs.ix = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x2A: { // ld ix,(nnnn)
            let value: number;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(addr);
            z80.regs.memptr = inc16(addr);
            value = word(z80.readByte(z80.regs.memptr), value);
            z80.regs.ix = value;
            break;
        }

        case 0x2B: { // dec ix
            break;
        }

        case 0x2C: { // inc ixl
            break;
        }

        case 0x2D: { // dec ixl
            break;
        }

        case 0x2E: { // ld ixl,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.ixl = value;
            break;
        }

        case 0x34: { // inc (ix+dd)
            break;
        }

        case 0x35: { // dec (ix+dd)
            break;
        }

        case 0x36: { // ld (ix+dd),nn
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x39: { // add ix,sp
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.sp;
            let result = z80.regs.ix + value;
            const lookup = (((z80.regs.ix & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.ix);
            z80.regs.ix = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x44: { // ld b,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.b = value;
            break;
        }

        case 0x45: { // ld b,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.b = value;
            break;
        }

        case 0x46: { // ld b,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.b = value;
            break;
        }

        case 0x4C: { // ld c,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.c = value;
            break;
        }

        case 0x4D: { // ld c,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.c = value;
            break;
        }

        case 0x4E: { // ld c,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.c = value;
            break;
        }

        case 0x54: { // ld d,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.d = value;
            break;
        }

        case 0x55: { // ld d,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.d = value;
            break;
        }

        case 0x56: { // ld d,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.d = value;
            break;
        }

        case 0x5C: { // ld e,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.e = value;
            break;
        }

        case 0x5D: { // ld e,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.e = value;
            break;
        }

        case 0x5E: { // ld e,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.e = value;
            break;
        }

        case 0x60: { // ld ixh,b
            let value: number;
            value = z80.regs.b;
            z80.regs.ixh = value;
            break;
        }

        case 0x61: { // ld ixh,c
            let value: number;
            value = z80.regs.c;
            z80.regs.ixh = value;
            break;
        }

        case 0x62: { // ld ixh,d
            let value: number;
            value = z80.regs.d;
            z80.regs.ixh = value;
            break;
        }

        case 0x63: { // ld ixh,e
            let value: number;
            value = z80.regs.e;
            z80.regs.ixh = value;
            break;
        }

        case 0x64: { // ld ixh,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.ixh = value;
            break;
        }

        case 0x65: { // ld ixh,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.ixh = value;
            break;
        }

        case 0x66: { // ld h,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.h = value;
            break;
        }

        case 0x67: { // ld ixh,a
            let value: number;
            value = z80.regs.a;
            z80.regs.ixh = value;
            break;
        }

        case 0x68: { // ld ixl,b
            let value: number;
            value = z80.regs.b;
            z80.regs.ixl = value;
            break;
        }

        case 0x69: { // ld ixl,c
            let value: number;
            value = z80.regs.c;
            z80.regs.ixl = value;
            break;
        }

        case 0x6A: { // ld ixl,d
            let value: number;
            value = z80.regs.d;
            z80.regs.ixl = value;
            break;
        }

        case 0x6B: { // ld ixl,e
            let value: number;
            value = z80.regs.e;
            z80.regs.ixl = value;
            break;
        }

        case 0x6C: { // ld ixl,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.ixl = value;
            break;
        }

        case 0x6D: { // ld ixl,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.ixl = value;
            break;
        }

        case 0x6E: { // ld l,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.l = value;
            break;
        }

        case 0x6F: { // ld ixl,a
            let value: number;
            value = z80.regs.a;
            z80.regs.ixl = value;
            break;
        }

        case 0x70: { // ld (ix+dd),b
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.b;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x71: { // ld (ix+dd),c
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.c;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x72: { // ld (ix+dd),d
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.d;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x73: { // ld (ix+dd),e
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.e;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x74: { // ld (ix+dd),h
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.h;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x75: { // ld (ix+dd),l
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.l;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x77: { // ld (ix+dd),a
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x7C: { // ld a,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.a = value;
            break;
        }

        case 0x7D: { // ld a,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.a = value;
            break;
        }

        case 0x7E: { // ld a,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a = value;
            break;
        }

        case 0x84: { // add a,ixh
            let value: number;
            value = z80.regs.ixh;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x85: { // add a,ixl
            let value: number;
            value = z80.regs.ixl;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x86: { // add a,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8C: { // adc a,ixh
            let value: number;
            value = z80.regs.ixh;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8D: { // adc a,ixl
            let value: number;
            value = z80.regs.ixl;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8E: { // adc a,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x94: { // sub a,ixh
            let value: number;
            value = z80.regs.ixh;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x95: { // sub a,ixl
            let value: number;
            value = z80.regs.ixl;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x96: { // sub a,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9C: { // sbc a,ixh
            let value: number;
            value = z80.regs.ixh;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9D: { // sbc a,ixl
            let value: number;
            value = z80.regs.ixl;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9E: { // sbc a,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0xA4: { // and a,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA5: { // and a,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA6: { // and a,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xAC: { // xor a,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAD: { // xor a,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAE: { // xor a,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB4: { // or a,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB5: { // or a,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB6: { // or a,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xBC: { // cp ixh
            let value: number;
            value = z80.regs.ixh;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBD: { // cp ixl
            let value: number;
            value = z80.regs.ixl;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBE: { // cp (ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xCB: { // shift ddcb
            decodeDDCB(z80);
            break;
        }

        case 0xE1: { // pop ix
            z80.regs.ix = z80.popWord();
            break;
        }

        case 0xE3: { // ex (sp),ix
            const rightValue = z80.regs.ix;
            const leftValueL = z80.readByte(z80.regs.sp);
            const leftValueH = z80.readByte(inc16(z80.regs.sp));
            z80.incTStateCount(1);
            z80.writeByte(inc16(z80.regs.sp), hi(rightValue));
            z80.writeByte(z80.regs.sp, lo(rightValue));
            z80.incTStateCount(2);
            z80.regs.memptr = word(leftValueH, leftValueL);
            z80.regs.ix = word(leftValueH, leftValueL);
            break;
        }

        case 0xE5: { // push ix
            z80.pushWord(z80.regs.ix);
            break;
        }

        case 0xE9: { // jp ix
            z80.regs.pc = z80.regs.ix;
            break;
        }

        case 0xF9: { // ld sp,ix
            let value: number;
            value = z80.regs.ix;
            z80.regs.sp = value;
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeDDCB(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x00: { // ld b,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x01: { // ld c,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x02: { // ld d,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x03: { // ld e,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x04: { // ld h,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x05: { // ld l,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x06: { // rlc (ix+dd)
            break;
        }

        case 0x07: { // ld a,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x08: { // ld b,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x09: { // ld c,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0A: { // ld d,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0B: { // ld e,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0C: { // ld h,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0D: { // ld l,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0E: { // rrc (ix+dd)
            break;
        }

        case 0x0F: { // ld a,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x10: { // ld b,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x11: { // ld c,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x12: { // ld d,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x13: { // ld e,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x14: { // ld h,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x15: { // ld l,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x16: { // rl (ix+dd)
            break;
        }

        case 0x17: { // ld a,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x18: { // ld b,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x19: { // ld c,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1A: { // ld d,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1B: { // ld e,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1C: { // ld h,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1D: { // ld l,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1E: { // rr (ix+dd)
            break;
        }

        case 0x1F: { // ld a,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x20: { // ld b,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x21: { // ld c,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x22: { // ld d,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x23: { // ld e,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x24: { // ld h,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x25: { // ld l,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x26: { // sla (ix+dd)
            break;
        }

        case 0x27: { // ld a,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x28: { // ld b,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x29: { // ld c,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2A: { // ld d,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2B: { // ld e,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2C: { // ld h,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2D: { // ld l,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2E: { // sra (ix+dd)
            break;
        }

        case 0x2F: { // ld a,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x30: { // ld b,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x31: { // ld c,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x32: { // ld d,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x33: { // ld e,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x34: { // ld h,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x35: { // ld l,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x36: { // sll (ix+dd)
            break;
        }

        case 0x37: { // ld a,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x38: { // ld b,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x39: { // ld c,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3A: { // ld d,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3B: { // ld e,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3C: { // ld h,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3D: { // ld l,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3E: { // srl (ix+dd)
            break;
        }

        case 0x3F: { // ld a,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x40: { // 
            // Undefined opcode.
            break;
        }

        case 0x41: { // 
            // Undefined opcode.
            break;
        }

        case 0x42: { // 
            // Undefined opcode.
            break;
        }

        case 0x43: { // 
            // Undefined opcode.
            break;
        }

        case 0x44: { // 
            // Undefined opcode.
            break;
        }

        case 0x45: { // 
            // Undefined opcode.
            break;
        }

        case 0x46: { // 
            // Undefined opcode.
            break;
        }

        case 0x47: { // bit 0,(ix+dd)
            break;
        }

        case 0x48: { // 
            // Undefined opcode.
            break;
        }

        case 0x49: { // 
            // Undefined opcode.
            break;
        }

        case 0x4A: { // 
            // Undefined opcode.
            break;
        }

        case 0x4B: { // 
            // Undefined opcode.
            break;
        }

        case 0x4C: { // 
            // Undefined opcode.
            break;
        }

        case 0x4D: { // 
            // Undefined opcode.
            break;
        }

        case 0x4E: { // 
            // Undefined opcode.
            break;
        }

        case 0x4F: { // bit 1,(ix+dd)
            break;
        }

        case 0x50: { // 
            // Undefined opcode.
            break;
        }

        case 0x51: { // 
            // Undefined opcode.
            break;
        }

        case 0x52: { // 
            // Undefined opcode.
            break;
        }

        case 0x53: { // 
            // Undefined opcode.
            break;
        }

        case 0x54: { // 
            // Undefined opcode.
            break;
        }

        case 0x55: { // 
            // Undefined opcode.
            break;
        }

        case 0x56: { // 
            // Undefined opcode.
            break;
        }

        case 0x57: { // bit 2,(ix+dd)
            break;
        }

        case 0x58: { // 
            // Undefined opcode.
            break;
        }

        case 0x59: { // 
            // Undefined opcode.
            break;
        }

        case 0x5A: { // 
            // Undefined opcode.
            break;
        }

        case 0x5B: { // 
            // Undefined opcode.
            break;
        }

        case 0x5C: { // 
            // Undefined opcode.
            break;
        }

        case 0x5D: { // 
            // Undefined opcode.
            break;
        }

        case 0x5E: { // 
            // Undefined opcode.
            break;
        }

        case 0x5F: { // bit 3,(ix+dd)
            break;
        }

        case 0x60: { // 
            // Undefined opcode.
            break;
        }

        case 0x61: { // 
            // Undefined opcode.
            break;
        }

        case 0x62: { // 
            // Undefined opcode.
            break;
        }

        case 0x63: { // 
            // Undefined opcode.
            break;
        }

        case 0x64: { // 
            // Undefined opcode.
            break;
        }

        case 0x65: { // 
            // Undefined opcode.
            break;
        }

        case 0x66: { // 
            // Undefined opcode.
            break;
        }

        case 0x67: { // bit 4,(ix+dd)
            break;
        }

        case 0x68: { // 
            // Undefined opcode.
            break;
        }

        case 0x69: { // 
            // Undefined opcode.
            break;
        }

        case 0x6A: { // 
            // Undefined opcode.
            break;
        }

        case 0x6B: { // 
            // Undefined opcode.
            break;
        }

        case 0x6C: { // 
            // Undefined opcode.
            break;
        }

        case 0x6D: { // 
            // Undefined opcode.
            break;
        }

        case 0x6E: { // 
            // Undefined opcode.
            break;
        }

        case 0x6F: { // bit 5,(ix+dd)
            break;
        }

        case 0x70: { // 
            // Undefined opcode.
            break;
        }

        case 0x71: { // 
            // Undefined opcode.
            break;
        }

        case 0x72: { // 
            // Undefined opcode.
            break;
        }

        case 0x73: { // 
            // Undefined opcode.
            break;
        }

        case 0x74: { // 
            // Undefined opcode.
            break;
        }

        case 0x75: { // 
            // Undefined opcode.
            break;
        }

        case 0x76: { // 
            // Undefined opcode.
            break;
        }

        case 0x77: { // bit 6,(ix+dd)
            break;
        }

        case 0x78: { // 
            // Undefined opcode.
            break;
        }

        case 0x79: { // 
            // Undefined opcode.
            break;
        }

        case 0x7A: { // 
            // Undefined opcode.
            break;
        }

        case 0x7B: { // 
            // Undefined opcode.
            break;
        }

        case 0x7C: { // 
            // Undefined opcode.
            break;
        }

        case 0x7D: { // 
            // Undefined opcode.
            break;
        }

        case 0x7E: { // 
            // Undefined opcode.
            break;
        }

        case 0x7F: { // bit 7,(ix+dd)
            break;
        }

        case 0x80: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x81: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x82: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x83: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x84: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x85: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x86: { // res 0,(ix+dd)
            break;
        }

        case 0x87: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x88: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x89: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8A: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8B: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8C: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8D: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8E: { // res 1,(ix+dd)
            break;
        }

        case 0x8F: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x90: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x91: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x92: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x93: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x94: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x95: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x96: { // res 2,(ix+dd)
            break;
        }

        case 0x97: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x98: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x99: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9A: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9B: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9C: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9D: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9E: { // res 3,(ix+dd)
            break;
        }

        case 0x9F: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA0: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA1: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA2: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA3: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA4: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA5: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA6: { // res 4,(ix+dd)
            break;
        }

        case 0xA7: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA8: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA9: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAA: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAB: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAC: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAD: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAE: { // res 5,(ix+dd)
            break;
        }

        case 0xAF: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB0: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB1: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB2: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB3: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB4: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB5: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB6: { // res 6,(ix+dd)
            break;
        }

        case 0xB7: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB8: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB9: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBA: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBB: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBC: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBD: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBE: { // res 7,(ix+dd)
            break;
        }

        case 0xBF: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC6: { // set 0,(ix+dd)
            break;
        }

        case 0xC7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCE: { // set 1,(ix+dd)
            break;
        }

        case 0xCF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD6: { // set 2,(ix+dd)
            break;
        }

        case 0xD7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDE: { // set 3,(ix+dd)
            break;
        }

        case 0xDF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE6: { // set 4,(ix+dd)
            break;
        }

        case 0xE7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xED: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEE: { // set 5,(ix+dd)
            break;
        }

        case 0xEF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF6: { // set 6,(ix+dd)
            break;
        }

        case 0xF7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFE: { // set 7,(ix+dd)
            break;
        }

        case 0xFF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeED(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x40: { // in b,(c)
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.b = z80.readPort(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.b];
            break;
        }

        case 0x41: { // out (c),b
            z80.writePort(z80.regs.bc, z80.regs.b);
            z80.regs.memptr = inc16(z80.regs.bc);
            break;
        }

        case 0x42: { // sbc hl,bc
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.bc;
            let result = z80.regs.hl - value;
            if ((z80.regs.f & Flag.C) !== 0) {
                result -= 1;
            }
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
            break;
        }

        case 0x43: { // ld (nnnn),bc
            let value: number;
            value = z80.regs.bc;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x44: { // 
            // Undefined opcode.
            break;
        }

        case 0x4C: { // 
            // Undefined opcode.
            break;
        }

        case 0x54: { // 
            // Undefined opcode.
            break;
        }

        case 0x5C: { // 
            // Undefined opcode.
            break;
        }

        case 0x64: { // 
            // Undefined opcode.
            break;
        }

        case 0x6C: { // 
            // Undefined opcode.
            break;
        }

        case 0x74: { // 
            // Undefined opcode.
            break;
        }

        case 0x7C: { // neg
            const value = z80.regs.a;
            z80.regs.a = 0;
            const diff = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            z80.regs.a = diff;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= z80.sz53Table[z80.regs.a];
            z80.regs.f = f;
            break;
        }

        case 0x45: { // 
            // Undefined opcode.
            break;
        }

        case 0x4D: { // 
            // Undefined opcode.
            break;
        }

        case 0x55: { // 
            // Undefined opcode.
            break;
        }

        case 0x5D: { // 
            // Undefined opcode.
            break;
        }

        case 0x65: { // 
            // Undefined opcode.
            break;
        }

        case 0x6D: { // 
            // Undefined opcode.
            break;
        }

        case 0x75: { // 
            // Undefined opcode.
            break;
        }

        case 0x7D: { // retn
            z80.regs.iff1 = z80.regs.iff2;
            z80.regs.pc = z80.popWord();
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0x46: { // 
            // Undefined opcode.
            break;
        }

        case 0x4E: { // 
            // Undefined opcode.
            break;
        }

        case 0x66: { // 
            // Undefined opcode.
            break;
        }

        case 0x6E: { // im 0
            z80.regs.im = 0;
            break;
        }

        case 0x47: { // ld i,a
            let value: number;
            value = z80.regs.a;
            z80.regs.i = value;
            break;
        }

        case 0x48: { // in c,(c)
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.c = z80.readPort(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.c];
            break;
        }

        case 0x49: { // out (c),c
            z80.writePort(z80.regs.bc, z80.regs.c);
            z80.regs.memptr = inc16(z80.regs.bc);
            break;
        }

        case 0x4A: { // adc hl,bc
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.bc;
            let result = z80.regs.hl + value;
            if ((z80.regs.f & Flag.C) !== 0) {
                result += 1;
            }
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
            break;
        }

        case 0x4B: { // ld bc,(nnnn)
            let value: number;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(addr);
            z80.regs.memptr = inc16(addr);
            value = word(z80.readByte(z80.regs.memptr), value);
            z80.regs.bc = value;
            break;
        }

        case 0x4F: { // ld r,a
            let value: number;
            value = z80.regs.a;
            z80.regs.r = value;
            break;
        }

        case 0x50: { // in d,(c)
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.d = z80.readPort(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.d];
            break;
        }

        case 0x51: { // out (c),d
            z80.writePort(z80.regs.bc, z80.regs.d);
            z80.regs.memptr = inc16(z80.regs.bc);
            break;
        }

        case 0x52: { // sbc hl,de
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.de;
            let result = z80.regs.hl - value;
            if ((z80.regs.f & Flag.C) !== 0) {
                result -= 1;
            }
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
            break;
        }

        case 0x53: { // ld (nnnn),de
            let value: number;
            value = z80.regs.de;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x56: { // 
            // Undefined opcode.
            break;
        }

        case 0x76: { // im 1
            z80.regs.im = 1;
            break;
        }

        case 0x57: { // ld a,i
            let value: number;
            value = z80.regs.i;
            z80.regs.a = value;
            break;
        }

        case 0x58: { // in e,(c)
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.e = z80.readPort(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.e];
            break;
        }

        case 0x59: { // out (c),e
            z80.writePort(z80.regs.bc, z80.regs.e);
            z80.regs.memptr = inc16(z80.regs.bc);
            break;
        }

        case 0x5A: { // adc hl,de
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.de;
            let result = z80.regs.hl + value;
            if ((z80.regs.f & Flag.C) !== 0) {
                result += 1;
            }
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
            break;
        }

        case 0x5B: { // ld de,(nnnn)
            let value: number;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(addr);
            z80.regs.memptr = inc16(addr);
            value = word(z80.readByte(z80.regs.memptr), value);
            z80.regs.de = value;
            break;
        }

        case 0x5E: { // 
            // Undefined opcode.
            break;
        }

        case 0x7E: { // im 2
            z80.regs.im = 2;
            break;
        }

        case 0x5F: { // ld a,r
            let value: number;
            value = z80.regs.r;
            z80.regs.a = value;
            break;
        }

        case 0x60: { // in h,(c)
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.h = z80.readPort(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.h];
            break;
        }

        case 0x61: { // out (c),h
            z80.writePort(z80.regs.bc, z80.regs.h);
            z80.regs.memptr = inc16(z80.regs.bc);
            break;
        }

        case 0x62: { // sbc hl,hl
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.hl;
            let result = z80.regs.hl - value;
            if ((z80.regs.f & Flag.C) !== 0) {
                result -= 1;
            }
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
            break;
        }

        case 0x63: { // ld (nnnn),hl
            let value: number;
            value = z80.regs.hl;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x67: { // rrd
            break;
        }

        case 0x68: { // in l,(c)
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.l = z80.readPort(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.l];
            break;
        }

        case 0x69: { // out (c),l
            z80.writePort(z80.regs.bc, z80.regs.l);
            z80.regs.memptr = inc16(z80.regs.bc);
            break;
        }

        case 0x6A: { // adc hl,hl
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.hl;
            let result = z80.regs.hl + value;
            if ((z80.regs.f & Flag.C) !== 0) {
                result += 1;
            }
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
            break;
        }

        case 0x6B: { // ld hl,(nnnn)
            let value: number;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(addr);
            z80.regs.memptr = inc16(addr);
            value = word(z80.readByte(z80.regs.memptr), value);
            z80.regs.hl = value;
            break;
        }

        case 0x6F: { // rld
            break;
        }

        case 0x70: { // in f,(c)
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.f = z80.readPort(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.f];
            break;
        }

        case 0x71: { // out (c),0
            z80.writePort(z80.regs.bc, 0x00);
            z80.regs.memptr = inc16(z80.regs.bc);
            break;
        }

        case 0x72: { // sbc hl,sp
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.sp;
            let result = z80.regs.hl - value;
            if ((z80.regs.f & Flag.C) !== 0) {
                result -= 1;
            }
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | Flag.N | overflowSubTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarrySubTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
            break;
        }

        case 0x73: { // ld (nnnn),sp
            let value: number;
            value = z80.regs.sp;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x78: { // in a,(c)
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.a = z80.readPort(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0x79: { // out (c),a
            z80.writePort(z80.regs.bc, z80.regs.a);
            z80.regs.memptr = inc16(z80.regs.bc);
            break;
        }

        case 0x7A: { // adc hl,sp
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.sp;
            let result = z80.regs.hl + value;
            if ((z80.regs.f & Flag.C) !== 0) {
                result += 1;
            }
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = ((result & 0x10000) !== 0 ? Flag.C : 0) | overflowAddTable[lookup >> 4] | ((result >> 8) & (Flag.X3 | Flag.X5 | Flag.S)) | halfCarryAddTable[lookup & 0x07] | (result !== 0 ? 0 : Flag.Z);
            break;
        }

        case 0x7B: { // ld sp,(nnnn)
            let value: number;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(addr);
            z80.regs.memptr = inc16(addr);
            value = word(z80.readByte(z80.regs.memptr), value);
            z80.regs.sp = value;
            break;
        }

        case 0xA0: { // ldi
            let value = z80.readByte(z80.regs.hl);
            z80.writeByte(z80.regs.de, value);
            z80.incTStateCount(2);
            z80.regs.bc = dec16(z80.regs.bc);
            value = add16(value, z80.regs.a);
            z80.regs.f = (z80.regs.f & (Flag.C | Flag.Z | Flag.S)) | (z80.regs.bc !== 0 ? Flag.V : 0) | (value & Flag.X3) | ((value & 0x02) !== 0 ? Flag.X5 : 0)
            z80.regs.hl = inc16(z80.regs.hl);
            z80.regs.de = inc16(z80.regs.de);
            break;
        }

        case 0xA1: { // cpi
            const value = z80.readByte(z80.regs.hl);
            let diff = (z80.regs.a - value) & 0xFF;
            const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
            z80.incTStateCount(5);
            z80.regs.bc = dec16(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | (z80.regs.bc !== 0 ? Flag.V : 0) | Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : Flag.Z) | (diff & Flag.S);
            if ((z80.regs.f & Flag.H) !== 0) diff = dec8(diff);
            z80.regs.f |= (diff & Flag.X3) | (((diff & 0x02) !== 0) ? Flag.X5 : 0);
            z80.regs.memptr = inc16(z80.regs.memptr);
            z80.regs.hl = inc16(z80.regs.hl);
            break;
        }

        case 0xA2: { // ini
            z80.incTStateCount(1);
            const value = z80.readPort(z80.regs.bc);
            z80.writeByte(z80.regs.hl, value);
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.b = dec8(z80.regs.b);
            const other = inc8(add8(value, z80.regs.c));
            z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
            z80.regs.hl = inc16(z80.regs.hl);
            break;
        }

        case 0xA3: { // outi
            z80.incTStateCount(1);
            const value = z80.readByte(z80.regs.hl);
            z80.regs.b = dec8(z80.regs.b);
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.writePort(z80.regs.bc, value);
            z80.regs.hl = inc16(z80.regs.hl);
            const other = add8(value, z80.regs.l);
            z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
            break;
        }

        case 0xA8: { // ldd
            let value = z80.readByte(z80.regs.hl);
            z80.writeByte(z80.regs.de, value);
            z80.incTStateCount(2);
            z80.regs.bc = dec16(z80.regs.bc);
            value = add16(value, z80.regs.a);
            z80.regs.f = (z80.regs.f & (Flag.C | Flag.Z | Flag.S)) | (z80.regs.bc !== 0 ? Flag.V : 0) | (value & Flag.X3) | ((value & 0x02) !== 0 ? Flag.X5 : 0)
            z80.regs.hl = dec16(z80.regs.hl);
            z80.regs.de = dec16(z80.regs.de);
            break;
        }

        case 0xA9: { // cpd
            const value = z80.readByte(z80.regs.hl);
            let diff = (z80.regs.a - value) & 0xFF;
            const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
            z80.incTStateCount(5);
            z80.regs.bc = dec16(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | (z80.regs.bc !== 0 ? Flag.V : 0) | Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : Flag.Z) | (diff & Flag.S);
            if ((z80.regs.f & Flag.H) !== 0) diff = dec8(diff);
            z80.regs.f |= (diff & Flag.X3) | (((diff & 0x02) !== 0) ? Flag.X5 : 0);
            z80.regs.memptr = dec16(z80.regs.memptr);
            z80.regs.hl = dec16(z80.regs.hl);
            break;
        }

        case 0xAA: { // ind
            z80.incTStateCount(1);
            const value = z80.readPort(z80.regs.bc);
            z80.writeByte(z80.regs.hl, value);
            z80.regs.memptr = dec16(z80.regs.bc);
            z80.regs.b = dec8(z80.regs.b);
            const other = dec8(add8(value, z80.regs.c));
            z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
            z80.regs.hl = dec16(z80.regs.hl);
            break;
        }

        case 0xAB: { // outd
            z80.incTStateCount(1);
            const value = z80.readByte(z80.regs.hl);
            z80.regs.b = dec8(z80.regs.b);
            z80.regs.memptr = dec16(z80.regs.bc);
            z80.writePort(z80.regs.bc, value);
            z80.regs.hl = dec16(z80.regs.hl);
            const other = add8(value, z80.regs.l);
            z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
            break;
        }

        case 0xB0: { // ldir
            let value = z80.readByte(z80.regs.hl);
            z80.writeByte(z80.regs.de, value);
            z80.incTStateCount(2);
            z80.regs.bc = dec16(z80.regs.bc);
            value = add16(value, z80.regs.a);
            z80.regs.f = (z80.regs.f & (Flag.C | Flag.Z | Flag.S)) | (z80.regs.bc !== 0 ? Flag.V : 0) | (value & Flag.X3) | ((value & 0x02) !== 0 ? Flag.X5 : 0)
            if (z80.regs.bc !== 0) {
                z80.incTStateCount(5);
                z80.regs.pc = add16(z80.regs.pc, -2);
                z80.regs.memptr = add16(z80.regs.pc, 1);
            }
            z80.regs.hl = inc16(z80.regs.hl);
            z80.regs.de = inc16(z80.regs.de);
            break;
        }

        case 0xB1: { // cpir
            const value = z80.readByte(z80.regs.hl);
            let diff = (z80.regs.a - value) & 0xFF;
            const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
            z80.incTStateCount(5);
            z80.regs.bc = dec16(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | (z80.regs.bc !== 0 ? Flag.V : 0) | Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : Flag.Z) | (diff & Flag.S);
            if ((z80.regs.f & Flag.H) !== 0) diff = dec8(diff);
            z80.regs.f |= (diff & Flag.X3) | (((diff & 0x02) !== 0) ? Flag.X5 : 0);
            if ((z80.regs.f & (Flag.V | Flag.Z)) === Flag.V) {
                z80.incTStateCount(5);
                z80.regs.pc = add16(z80.regs.pc, -2);
                z80.regs.memptr = add16(z80.regs.pc, 1);
            } else {
                z80.regs.memptr = inc16(z80.regs.memptr);
            }
            z80.regs.hl = inc16(z80.regs.hl);
            break;
        }

        case 0xB2: { // inir
            z80.incTStateCount(1);
            const value = z80.readPort(z80.regs.bc);
            z80.writeByte(z80.regs.hl, value);
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.regs.b = dec8(z80.regs.b);
            const other = inc8(add8(value, z80.regs.c));
            z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
            if (z80.regs.b > 0) {
                z80.incTStateCount(5);
                z80.regs.pc = add16(z80.regs.pc, -2);
            }
            z80.regs.hl = inc16(z80.regs.hl);
            break;
        }

        case 0xB3: { // otir
            z80.incTStateCount(1);
            const value = z80.readByte(z80.regs.hl);
            z80.regs.b = dec8(z80.regs.b);
            z80.regs.memptr = inc16(z80.regs.bc);
            z80.writePort(z80.regs.bc, value);
            z80.regs.hl = inc16(z80.regs.hl);
            const other = add8(value, z80.regs.l);
            z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
            if (z80.regs.b > 0) {
                z80.incTStateCount(5);
                z80.regs.pc = add16(z80.regs.pc, -2);
            }
            break;
        }

        case 0xB8: { // lddr
            let value = z80.readByte(z80.regs.hl);
            z80.writeByte(z80.regs.de, value);
            z80.incTStateCount(2);
            z80.regs.bc = dec16(z80.regs.bc);
            value = add16(value, z80.regs.a);
            z80.regs.f = (z80.regs.f & (Flag.C | Flag.Z | Flag.S)) | (z80.regs.bc !== 0 ? Flag.V : 0) | (value & Flag.X3) | ((value & 0x02) !== 0 ? Flag.X5 : 0)
            if (z80.regs.bc !== 0) {
                z80.incTStateCount(5);
                z80.regs.pc = add16(z80.regs.pc, -2);
                z80.regs.memptr = add16(z80.regs.pc, 1);
            }
            z80.regs.hl = dec16(z80.regs.hl);
            z80.regs.de = dec16(z80.regs.de);
            break;
        }

        case 0xB9: { // cpdr
            const value = z80.readByte(z80.regs.hl);
            let diff = (z80.regs.a - value) & 0xFF;
            const lookup = ((z80.regs.a & 0x08) >> 3) | ((value & 0x08) >> 2) | ((diff & 0x08) >> 1);
            z80.incTStateCount(5);
            z80.regs.bc = dec16(z80.regs.bc);
            z80.regs.f = (z80.regs.f & Flag.C) | (z80.regs.bc !== 0 ? Flag.V : 0) | Flag.N | halfCarrySubTable[lookup] | (diff !== 0 ? 0 : Flag.Z) | (diff & Flag.S);
            if ((z80.regs.f & Flag.H) !== 0) diff = dec8(diff);
            z80.regs.f |= (diff & Flag.X3) | (((diff & 0x02) !== 0) ? Flag.X5 : 0);
            if ((z80.regs.f & (Flag.V | Flag.Z)) === Flag.V) {
                z80.incTStateCount(5);
                z80.regs.pc = add16(z80.regs.pc, -2);
                z80.regs.memptr = add16(z80.regs.pc, 1);
            } else {
                z80.regs.memptr = dec16(z80.regs.memptr);
            }
            z80.regs.hl = dec16(z80.regs.hl);
            break;
        }

        case 0xBA: { // indr
            z80.incTStateCount(1);
            const value = z80.readPort(z80.regs.bc);
            z80.writeByte(z80.regs.hl, value);
            z80.regs.memptr = dec16(z80.regs.bc);
            z80.regs.b = dec8(z80.regs.b);
            const other = dec8(add8(value, z80.regs.c));
            z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
            if (z80.regs.b > 0) {
                z80.incTStateCount(5);
                z80.regs.pc = add16(z80.regs.pc, -2);
            }
            z80.regs.hl = dec16(z80.regs.hl);
            break;
        }

        case 0xBB: { // otdr
            z80.incTStateCount(1);
            const value = z80.readByte(z80.regs.hl);
            z80.regs.b = dec8(z80.regs.b);
            z80.regs.memptr = dec16(z80.regs.bc);
            z80.writePort(z80.regs.bc, value);
            z80.regs.hl = dec16(z80.regs.hl);
            const other = add8(value, z80.regs.l);
            z80.regs.f = (value & 0x80 ? Flag.N : 0 ) | (other < value ? Flag.H | Flag.C : 0) | (z80.parityTable[(other & 0x07) ^ z80.regs.b] ? Flag.P : 0) | z80.sz53Table[z80.regs.b];
            if (z80.regs.b > 0) {
                z80.incTStateCount(5);
                z80.regs.pc = add16(z80.regs.pc, -2);
            }
            break;
        }

        case 0xFB: { // slttrap
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeFD(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x09: { // add iy,bc
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.bc;
            let result = z80.regs.iy + value;
            const lookup = (((z80.regs.iy & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.iy);
            z80.regs.iy = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x19: { // add iy,de
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.de;
            let result = z80.regs.iy + value;
            const lookup = (((z80.regs.iy & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.iy);
            z80.regs.iy = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x21: { // ld iy,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.iy = value;
            break;
        }

        case 0x22: { // ld (nnnn),iy
            let value: number;
            value = z80.regs.iy;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x23: { // inc iy
            break;
        }

        case 0x24: { // inc iyh
            break;
        }

        case 0x25: { // dec iyh
            break;
        }

        case 0x26: { // ld iyh,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.iyh = value;
            break;
        }

        case 0x29: { // add iy,iy
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.iy;
            let result = z80.regs.iy + value;
            const lookup = (((z80.regs.iy & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.iy);
            z80.regs.iy = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x2A: { // ld iy,(nnnn)
            let value: number;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(addr);
            z80.regs.memptr = inc16(addr);
            value = word(z80.readByte(z80.regs.memptr), value);
            z80.regs.iy = value;
            break;
        }

        case 0x2B: { // dec iy
            break;
        }

        case 0x2C: { // inc iyl
            break;
        }

        case 0x2D: { // dec iyl
            break;
        }

        case 0x2E: { // ld iyl,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.iyl = value;
            break;
        }

        case 0x34: { // inc (iy+dd)
            break;
        }

        case 0x35: { // dec (iy+dd)
            break;
        }

        case 0x36: { // ld (iy+dd),nn
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x39: { // add iy,sp
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.sp;
            let result = z80.regs.iy + value;
            const lookup = (((z80.regs.iy & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.iy);
            z80.regs.iy = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x44: { // ld b,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.b = value;
            break;
        }

        case 0x45: { // ld b,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.b = value;
            break;
        }

        case 0x46: { // ld b,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.b = value;
            break;
        }

        case 0x4C: { // ld c,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.c = value;
            break;
        }

        case 0x4D: { // ld c,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.c = value;
            break;
        }

        case 0x4E: { // ld c,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.c = value;
            break;
        }

        case 0x54: { // ld d,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.d = value;
            break;
        }

        case 0x55: { // ld d,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.d = value;
            break;
        }

        case 0x56: { // ld d,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.d = value;
            break;
        }

        case 0x5C: { // ld e,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.e = value;
            break;
        }

        case 0x5D: { // ld e,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.e = value;
            break;
        }

        case 0x5E: { // ld e,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.e = value;
            break;
        }

        case 0x60: { // ld iyh,b
            let value: number;
            value = z80.regs.b;
            z80.regs.iyh = value;
            break;
        }

        case 0x61: { // ld iyh,c
            let value: number;
            value = z80.regs.c;
            z80.regs.iyh = value;
            break;
        }

        case 0x62: { // ld iyh,d
            let value: number;
            value = z80.regs.d;
            z80.regs.iyh = value;
            break;
        }

        case 0x63: { // ld iyh,e
            let value: number;
            value = z80.regs.e;
            z80.regs.iyh = value;
            break;
        }

        case 0x64: { // ld iyh,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.iyh = value;
            break;
        }

        case 0x65: { // ld iyh,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.iyh = value;
            break;
        }

        case 0x66: { // ld h,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.h = value;
            break;
        }

        case 0x67: { // ld iyh,a
            let value: number;
            value = z80.regs.a;
            z80.regs.iyh = value;
            break;
        }

        case 0x68: { // ld iyl,b
            let value: number;
            value = z80.regs.b;
            z80.regs.iyl = value;
            break;
        }

        case 0x69: { // ld iyl,c
            let value: number;
            value = z80.regs.c;
            z80.regs.iyl = value;
            break;
        }

        case 0x6A: { // ld iyl,d
            let value: number;
            value = z80.regs.d;
            z80.regs.iyl = value;
            break;
        }

        case 0x6B: { // ld iyl,e
            let value: number;
            value = z80.regs.e;
            z80.regs.iyl = value;
            break;
        }

        case 0x6C: { // ld iyl,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.iyl = value;
            break;
        }

        case 0x6D: { // ld iyl,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.iyl = value;
            break;
        }

        case 0x6E: { // ld l,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.l = value;
            break;
        }

        case 0x6F: { // ld iyl,a
            let value: number;
            value = z80.regs.a;
            z80.regs.iyl = value;
            break;
        }

        case 0x70: { // ld (iy+dd),b
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.b;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x71: { // ld (iy+dd),c
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.c;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x72: { // ld (iy+dd),d
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.d;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x73: { // ld (iy+dd),e
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.e;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x74: { // ld (iy+dd),h
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.h;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x75: { // ld (iy+dd),l
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.l;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x77: { // ld (iy+dd),a
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x7C: { // ld a,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.a = value;
            break;
        }

        case 0x7D: { // ld a,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.a = value;
            break;
        }

        case 0x7E: { // ld a,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a = value;
            break;
        }

        case 0x84: { // add a,iyh
            let value: number;
            value = z80.regs.iyh;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x85: { // add a,iyl
            let value: number;
            value = z80.regs.iyl;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x86: { // add a,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8C: { // adc a,iyh
            let value: number;
            value = z80.regs.iyh;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8D: { // adc a,iyl
            let value: number;
            value = z80.regs.iyl;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8E: { // adc a,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x94: { // sub a,iyh
            let value: number;
            value = z80.regs.iyh;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x95: { // sub a,iyl
            let value: number;
            value = z80.regs.iyl;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x96: { // sub a,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9C: { // sbc a,iyh
            let value: number;
            value = z80.regs.iyh;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9D: { // sbc a,iyl
            let value: number;
            value = z80.regs.iyl;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9E: { // sbc a,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0xA4: { // and a,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA5: { // and a,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA6: { // and a,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xAC: { // xor a,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAD: { // xor a,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAE: { // xor a,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB4: { // or a,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB5: { // or a,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB6: { // or a,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.incTStateCount(5);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xBC: { // cp iyh
            let value: number;
            value = z80.regs.iyh;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBD: { // cp iyl
            let value: number;
            value = z80.regs.iyl;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBE: { // cp (iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xCB: { // shift fdcb
            decodeFDCB(z80);
            break;
        }

        case 0xE1: { // pop iy
            z80.regs.iy = z80.popWord();
            break;
        }

        case 0xE3: { // ex (sp),iy
            const rightValue = z80.regs.iy;
            const leftValueL = z80.readByte(z80.regs.sp);
            const leftValueH = z80.readByte(inc16(z80.regs.sp));
            z80.incTStateCount(1);
            z80.writeByte(inc16(z80.regs.sp), hi(rightValue));
            z80.writeByte(z80.regs.sp, lo(rightValue));
            z80.incTStateCount(2);
            z80.regs.memptr = word(leftValueH, leftValueL);
            z80.regs.iy = word(leftValueH, leftValueL);
            break;
        }

        case 0xE5: { // push iy
            z80.pushWord(z80.regs.iy);
            break;
        }

        case 0xE9: { // jp iy
            z80.regs.pc = z80.regs.iy;
            break;
        }

        case 0xF9: { // ld sp,iy
            let value: number;
            value = z80.regs.iy;
            z80.regs.sp = value;
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeFDCB(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x00: { // ld b,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x01: { // ld c,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x02: { // ld d,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x03: { // ld e,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x04: { // ld h,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x05: { // ld l,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x06: { // rlc (iy+dd)
            break;
        }

        case 0x07: { // ld a,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x08: { // ld b,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x09: { // ld c,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0A: { // ld d,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0B: { // ld e,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0C: { // ld h,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0D: { // ld l,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0E: { // rrc (iy+dd)
            break;
        }

        case 0x0F: { // ld a,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x10: { // ld b,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x11: { // ld c,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x12: { // ld d,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x13: { // ld e,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x14: { // ld h,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x15: { // ld l,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x16: { // rl (iy+dd)
            break;
        }

        case 0x17: { // ld a,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x18: { // ld b,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x19: { // ld c,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1A: { // ld d,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1B: { // ld e,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1C: { // ld h,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1D: { // ld l,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1E: { // rr (iy+dd)
            break;
        }

        case 0x1F: { // ld a,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x20: { // ld b,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x21: { // ld c,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x22: { // ld d,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x23: { // ld e,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x24: { // ld h,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x25: { // ld l,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x26: { // sla (iy+dd)
            break;
        }

        case 0x27: { // ld a,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x28: { // ld b,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x29: { // ld c,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2A: { // ld d,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2B: { // ld e,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2C: { // ld h,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2D: { // ld l,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2E: { // sra (iy+dd)
            break;
        }

        case 0x2F: { // ld a,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x30: { // ld b,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x31: { // ld c,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x32: { // ld d,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x33: { // ld e,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x34: { // ld h,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x35: { // ld l,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x36: { // sll (iy+dd)
            break;
        }

        case 0x37: { // ld a,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x38: { // ld b,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x39: { // ld c,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3A: { // ld d,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3B: { // ld e,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3C: { // ld h,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3D: { // ld l,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3E: { // srl (iy+dd)
            break;
        }

        case 0x3F: { // ld a,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x40: { // 
            // Undefined opcode.
            break;
        }

        case 0x41: { // 
            // Undefined opcode.
            break;
        }

        case 0x42: { // 
            // Undefined opcode.
            break;
        }

        case 0x43: { // 
            // Undefined opcode.
            break;
        }

        case 0x44: { // 
            // Undefined opcode.
            break;
        }

        case 0x45: { // 
            // Undefined opcode.
            break;
        }

        case 0x46: { // 
            // Undefined opcode.
            break;
        }

        case 0x47: { // bit 0,(iy+dd)
            break;
        }

        case 0x48: { // 
            // Undefined opcode.
            break;
        }

        case 0x49: { // 
            // Undefined opcode.
            break;
        }

        case 0x4A: { // 
            // Undefined opcode.
            break;
        }

        case 0x4B: { // 
            // Undefined opcode.
            break;
        }

        case 0x4C: { // 
            // Undefined opcode.
            break;
        }

        case 0x4D: { // 
            // Undefined opcode.
            break;
        }

        case 0x4E: { // 
            // Undefined opcode.
            break;
        }

        case 0x4F: { // bit 1,(iy+dd)
            break;
        }

        case 0x50: { // 
            // Undefined opcode.
            break;
        }

        case 0x51: { // 
            // Undefined opcode.
            break;
        }

        case 0x52: { // 
            // Undefined opcode.
            break;
        }

        case 0x53: { // 
            // Undefined opcode.
            break;
        }

        case 0x54: { // 
            // Undefined opcode.
            break;
        }

        case 0x55: { // 
            // Undefined opcode.
            break;
        }

        case 0x56: { // 
            // Undefined opcode.
            break;
        }

        case 0x57: { // bit 2,(iy+dd)
            break;
        }

        case 0x58: { // 
            // Undefined opcode.
            break;
        }

        case 0x59: { // 
            // Undefined opcode.
            break;
        }

        case 0x5A: { // 
            // Undefined opcode.
            break;
        }

        case 0x5B: { // 
            // Undefined opcode.
            break;
        }

        case 0x5C: { // 
            // Undefined opcode.
            break;
        }

        case 0x5D: { // 
            // Undefined opcode.
            break;
        }

        case 0x5E: { // 
            // Undefined opcode.
            break;
        }

        case 0x5F: { // bit 3,(iy+dd)
            break;
        }

        case 0x60: { // 
            // Undefined opcode.
            break;
        }

        case 0x61: { // 
            // Undefined opcode.
            break;
        }

        case 0x62: { // 
            // Undefined opcode.
            break;
        }

        case 0x63: { // 
            // Undefined opcode.
            break;
        }

        case 0x64: { // 
            // Undefined opcode.
            break;
        }

        case 0x65: { // 
            // Undefined opcode.
            break;
        }

        case 0x66: { // 
            // Undefined opcode.
            break;
        }

        case 0x67: { // bit 4,(iy+dd)
            break;
        }

        case 0x68: { // 
            // Undefined opcode.
            break;
        }

        case 0x69: { // 
            // Undefined opcode.
            break;
        }

        case 0x6A: { // 
            // Undefined opcode.
            break;
        }

        case 0x6B: { // 
            // Undefined opcode.
            break;
        }

        case 0x6C: { // 
            // Undefined opcode.
            break;
        }

        case 0x6D: { // 
            // Undefined opcode.
            break;
        }

        case 0x6E: { // 
            // Undefined opcode.
            break;
        }

        case 0x6F: { // bit 5,(iy+dd)
            break;
        }

        case 0x70: { // 
            // Undefined opcode.
            break;
        }

        case 0x71: { // 
            // Undefined opcode.
            break;
        }

        case 0x72: { // 
            // Undefined opcode.
            break;
        }

        case 0x73: { // 
            // Undefined opcode.
            break;
        }

        case 0x74: { // 
            // Undefined opcode.
            break;
        }

        case 0x75: { // 
            // Undefined opcode.
            break;
        }

        case 0x76: { // 
            // Undefined opcode.
            break;
        }

        case 0x77: { // bit 6,(iy+dd)
            break;
        }

        case 0x78: { // 
            // Undefined opcode.
            break;
        }

        case 0x79: { // 
            // Undefined opcode.
            break;
        }

        case 0x7A: { // 
            // Undefined opcode.
            break;
        }

        case 0x7B: { // 
            // Undefined opcode.
            break;
        }

        case 0x7C: { // 
            // Undefined opcode.
            break;
        }

        case 0x7D: { // 
            // Undefined opcode.
            break;
        }

        case 0x7E: { // 
            // Undefined opcode.
            break;
        }

        case 0x7F: { // bit 7,(iy+dd)
            break;
        }

        case 0x80: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x81: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x82: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x83: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x84: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x85: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x86: { // res 0,(iy+dd)
            break;
        }

        case 0x87: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x88: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x89: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8A: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8B: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8C: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8D: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8E: { // res 1,(iy+dd)
            break;
        }

        case 0x8F: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x90: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x91: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x92: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x93: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x94: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x95: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x96: { // res 2,(iy+dd)
            break;
        }

        case 0x97: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x98: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x99: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9A: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9B: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9C: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9D: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9E: { // res 3,(iy+dd)
            break;
        }

        case 0x9F: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA0: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA1: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA2: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA3: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA4: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA5: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA6: { // res 4,(iy+dd)
            break;
        }

        case 0xA7: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA8: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA9: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAA: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAB: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAC: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAD: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAE: { // res 5,(iy+dd)
            break;
        }

        case 0xAF: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB0: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB1: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB2: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB3: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB4: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB5: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB6: { // res 6,(iy+dd)
            break;
        }

        case 0xB7: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB8: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB9: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBA: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBB: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBC: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBD: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBE: { // res 7,(iy+dd)
            break;
        }

        case 0xBF: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC6: { // set 0,(iy+dd)
            break;
        }

        case 0xC7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCE: { // set 1,(iy+dd)
            break;
        }

        case 0xCF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD6: { // set 2,(iy+dd)
            break;
        }

        case 0xD7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDE: { // set 3,(iy+dd)
            break;
        }

        case 0xDF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE6: { // set 4,(iy+dd)
            break;
        }

        case 0xE7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xED: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEE: { // set 5,(iy+dd)
            break;
        }

        case 0xEF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF6: { // set 6,(iy+dd)
            break;
        }

        case 0xF7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFE: { // set 7,(iy+dd)
            break;
        }

        case 0xFF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

export function decode(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x00: { // nop
            break;
        }

        case 0x01: { // ld bc,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.bc = value;
            break;
        }

        case 0x02: { // ld (bc),a
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.bc));
            z80.writeByte(z80.regs.bc, value);
            break;
        }

        case 0x03: { // inc bc
            break;
        }

        case 0x04: { // inc b
            break;
        }

        case 0x05: { // dec b
            break;
        }

        case 0x06: { // ld b,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.b = value;
            break;
        }

        case 0x07: { // rlca
            break;
        }

        case 0x08: { // ex af,af'
            const rightValue = z80.regs.afPrime;
            z80.regs.afPrime = z80.regs.af;
            z80.regs.af = rightValue;
            break;
        }

        case 0x09: { // add hl,bc
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.bc;
            let result = z80.regs.hl + value;
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x0A: { // ld a,(bc)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.bc);
            value = z80.readByte(z80.regs.bc);
            z80.regs.a = value;
            break;
        }

        case 0x0B: { // dec bc
            break;
        }

        case 0x0C: { // inc c
            break;
        }

        case 0x0D: { // dec c
            break;
        }

        case 0x0E: { // ld c,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.c = value;
            break;
        }

        case 0x0F: { // rrca
            break;
        }

        case 0x10: { // djnz offset
            break;
        }

        case 0x11: { // ld de,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.de = value;
            break;
        }

        case 0x12: { // ld (de),a
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.de));
            z80.writeByte(z80.regs.de, value);
            break;
        }

        case 0x13: { // inc de
            break;
        }

        case 0x14: { // inc d
            break;
        }

        case 0x15: { // dec d
            break;
        }

        case 0x16: { // ld d,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.d = value;
            break;
        }

        case 0x17: { // rla
            break;
        }

        case 0x18: { // jr offset
            break;
        }

        case 0x19: { // add hl,de
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.de;
            let result = z80.regs.hl + value;
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x1A: { // ld a,(de)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.de);
            value = z80.readByte(z80.regs.de);
            z80.regs.a = value;
            break;
        }

        case 0x1B: { // dec de
            break;
        }

        case 0x1C: { // inc e
            break;
        }

        case 0x1D: { // dec e
            break;
        }

        case 0x1E: { // ld e,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.e = value;
            break;
        }

        case 0x1F: { // rra
            break;
        }

        case 0x20: { // jr nz,offset
            break;
        }

        case 0x21: { // ld hl,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.hl = value;
            break;
        }

        case 0x22: { // ld (nnnn),hl
            let value: number;
            value = z80.regs.hl;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x23: { // inc hl
            break;
        }

        case 0x24: { // inc h
            break;
        }

        case 0x25: { // dec h
            break;
        }

        case 0x26: { // ld h,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.h = value;
            break;
        }

        case 0x27: { // daa
            break;
        }

        case 0x28: { // jr z,offset
            break;
        }

        case 0x29: { // add hl,hl
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.hl;
            let result = z80.regs.hl + value;
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x2A: { // ld hl,(nnnn)
            let value: number;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(addr);
            z80.regs.memptr = inc16(addr);
            value = word(z80.readByte(z80.regs.memptr), value);
            z80.regs.hl = value;
            break;
        }

        case 0x2B: { // dec hl
            break;
        }

        case 0x2C: { // inc l
            break;
        }

        case 0x2D: { // dec l
            break;
        }

        case 0x2E: { // ld l,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.l = value;
            break;
        }

        case 0x2F: { // cpl
            break;
        }

        case 0x30: { // jr nc,offset
            break;
        }

        case 0x31: { // ld sp,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.sp = value;
            break;
        }

        case 0x32: { // ld (nnnn),a
            let value: number;
            value = z80.regs.a;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(value, z80.regs.a);
            break;
        }

        case 0x33: { // inc sp
            break;
        }

        case 0x34: { // inc (hl)
            break;
        }

        case 0x35: { // dec (hl)
            break;
        }

        case 0x36: { // ld (hl),nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x37: { // scf
            break;
        }

        case 0x38: { // jr c,offset
            break;
        }

        case 0x39: { // add hl,sp
            let value: number;
            z80.incTStateCount(7);
            value = z80.regs.sp;
            let result = z80.regs.hl + value;
            const lookup = (((z80.regs.hl & 0x0800) >> 11) |
                           ((value & 0x0800) >> 10) |
                           ((result & 0x0800) >> 9)) & 0xFF;
            z80.regs.memptr = inc16(z80.regs.hl);
            z80.regs.hl = result & 0xFFFF;
            z80.regs.f = (z80.regs.f & (Flag.V | Flag.Z | Flag.S)) | ((result & 0x10000) !== 0 ? Flag.C : 0) | ((result >> 8) & (Flag.X3 | Flag.X5)) | halfCarryAddTable[lookup];
            break;
        }

        case 0x3A: { // ld a,(nnnn)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(value);
            z80.regs.memptr = inc16(value);
            z80.regs.a = value;
            break;
        }

        case 0x3B: { // dec sp
            break;
        }

        case 0x3C: { // inc a
            break;
        }

        case 0x3D: { // dec a
            break;
        }

        case 0x3E: { // ld a,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.a = value;
            break;
        }

        case 0x3F: { // ccf
            break;
        }

        case 0x40: { // ld b,b
            let value: number;
            value = z80.regs.b;
            z80.regs.b = value;
            break;
        }

        case 0x41: { // ld b,c
            let value: number;
            value = z80.regs.c;
            z80.regs.b = value;
            break;
        }

        case 0x42: { // ld b,d
            let value: number;
            value = z80.regs.d;
            z80.regs.b = value;
            break;
        }

        case 0x43: { // ld b,e
            let value: number;
            value = z80.regs.e;
            z80.regs.b = value;
            break;
        }

        case 0x44: { // ld b,h
            let value: number;
            value = z80.regs.h;
            z80.regs.b = value;
            break;
        }

        case 0x45: { // ld b,l
            let value: number;
            value = z80.regs.l;
            z80.regs.b = value;
            break;
        }

        case 0x46: { // ld b,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.b = value;
            break;
        }

        case 0x47: { // ld b,a
            let value: number;
            value = z80.regs.a;
            z80.regs.b = value;
            break;
        }

        case 0x48: { // ld c,b
            let value: number;
            value = z80.regs.b;
            z80.regs.c = value;
            break;
        }

        case 0x49: { // ld c,c
            let value: number;
            value = z80.regs.c;
            z80.regs.c = value;
            break;
        }

        case 0x4A: { // ld c,d
            let value: number;
            value = z80.regs.d;
            z80.regs.c = value;
            break;
        }

        case 0x4B: { // ld c,e
            let value: number;
            value = z80.regs.e;
            z80.regs.c = value;
            break;
        }

        case 0x4C: { // ld c,h
            let value: number;
            value = z80.regs.h;
            z80.regs.c = value;
            break;
        }

        case 0x4D: { // ld c,l
            let value: number;
            value = z80.regs.l;
            z80.regs.c = value;
            break;
        }

        case 0x4E: { // ld c,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.c = value;
            break;
        }

        case 0x4F: { // ld c,a
            let value: number;
            value = z80.regs.a;
            z80.regs.c = value;
            break;
        }

        case 0x50: { // ld d,b
            let value: number;
            value = z80.regs.b;
            z80.regs.d = value;
            break;
        }

        case 0x51: { // ld d,c
            let value: number;
            value = z80.regs.c;
            z80.regs.d = value;
            break;
        }

        case 0x52: { // ld d,d
            let value: number;
            value = z80.regs.d;
            z80.regs.d = value;
            break;
        }

        case 0x53: { // ld d,e
            let value: number;
            value = z80.regs.e;
            z80.regs.d = value;
            break;
        }

        case 0x54: { // ld d,h
            let value: number;
            value = z80.regs.h;
            z80.regs.d = value;
            break;
        }

        case 0x55: { // ld d,l
            let value: number;
            value = z80.regs.l;
            z80.regs.d = value;
            break;
        }

        case 0x56: { // ld d,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.d = value;
            break;
        }

        case 0x57: { // ld d,a
            let value: number;
            value = z80.regs.a;
            z80.regs.d = value;
            break;
        }

        case 0x58: { // ld e,b
            let value: number;
            value = z80.regs.b;
            z80.regs.e = value;
            break;
        }

        case 0x59: { // ld e,c
            let value: number;
            value = z80.regs.c;
            z80.regs.e = value;
            break;
        }

        case 0x5A: { // ld e,d
            let value: number;
            value = z80.regs.d;
            z80.regs.e = value;
            break;
        }

        case 0x5B: { // ld e,e
            let value: number;
            value = z80.regs.e;
            z80.regs.e = value;
            break;
        }

        case 0x5C: { // ld e,h
            let value: number;
            value = z80.regs.h;
            z80.regs.e = value;
            break;
        }

        case 0x5D: { // ld e,l
            let value: number;
            value = z80.regs.l;
            z80.regs.e = value;
            break;
        }

        case 0x5E: { // ld e,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.e = value;
            break;
        }

        case 0x5F: { // ld e,a
            let value: number;
            value = z80.regs.a;
            z80.regs.e = value;
            break;
        }

        case 0x60: { // ld h,b
            let value: number;
            value = z80.regs.b;
            z80.regs.h = value;
            break;
        }

        case 0x61: { // ld h,c
            let value: number;
            value = z80.regs.c;
            z80.regs.h = value;
            break;
        }

        case 0x62: { // ld h,d
            let value: number;
            value = z80.regs.d;
            z80.regs.h = value;
            break;
        }

        case 0x63: { // ld h,e
            let value: number;
            value = z80.regs.e;
            z80.regs.h = value;
            break;
        }

        case 0x64: { // ld h,h
            let value: number;
            value = z80.regs.h;
            z80.regs.h = value;
            break;
        }

        case 0x65: { // ld h,l
            let value: number;
            value = z80.regs.l;
            z80.regs.h = value;
            break;
        }

        case 0x66: { // ld h,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.h = value;
            break;
        }

        case 0x67: { // ld h,a
            let value: number;
            value = z80.regs.a;
            z80.regs.h = value;
            break;
        }

        case 0x68: { // ld l,b
            let value: number;
            value = z80.regs.b;
            z80.regs.l = value;
            break;
        }

        case 0x69: { // ld l,c
            let value: number;
            value = z80.regs.c;
            z80.regs.l = value;
            break;
        }

        case 0x6A: { // ld l,d
            let value: number;
            value = z80.regs.d;
            z80.regs.l = value;
            break;
        }

        case 0x6B: { // ld l,e
            let value: number;
            value = z80.regs.e;
            z80.regs.l = value;
            break;
        }

        case 0x6C: { // ld l,h
            let value: number;
            value = z80.regs.h;
            z80.regs.l = value;
            break;
        }

        case 0x6D: { // ld l,l
            let value: number;
            value = z80.regs.l;
            z80.regs.l = value;
            break;
        }

        case 0x6E: { // ld l,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.l = value;
            break;
        }

        case 0x6F: { // ld l,a
            let value: number;
            value = z80.regs.a;
            z80.regs.l = value;
            break;
        }

        case 0x70: { // ld (hl),b
            let value: number;
            value = z80.regs.b;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x71: { // ld (hl),c
            let value: number;
            value = z80.regs.c;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x72: { // ld (hl),d
            let value: number;
            value = z80.regs.d;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x73: { // ld (hl),e
            let value: number;
            value = z80.regs.e;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x74: { // ld (hl),h
            let value: number;
            value = z80.regs.h;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x75: { // ld (hl),l
            let value: number;
            value = z80.regs.l;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x76: { // halt
            break;
        }

        case 0x77: { // ld (hl),a
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x78: { // ld a,b
            let value: number;
            value = z80.regs.b;
            z80.regs.a = value;
            break;
        }

        case 0x79: { // ld a,c
            let value: number;
            value = z80.regs.c;
            z80.regs.a = value;
            break;
        }

        case 0x7A: { // ld a,d
            let value: number;
            value = z80.regs.d;
            z80.regs.a = value;
            break;
        }

        case 0x7B: { // ld a,e
            let value: number;
            value = z80.regs.e;
            z80.regs.a = value;
            break;
        }

        case 0x7C: { // ld a,h
            let value: number;
            value = z80.regs.h;
            z80.regs.a = value;
            break;
        }

        case 0x7D: { // ld a,l
            let value: number;
            value = z80.regs.l;
            z80.regs.a = value;
            break;
        }

        case 0x7E: { // ld a,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.a = value;
            break;
        }

        case 0x7F: { // ld a,a
            let value: number;
            value = z80.regs.a;
            z80.regs.a = value;
            break;
        }

        case 0x80: { // add a,b
            let value: number;
            value = z80.regs.b;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x81: { // add a,c
            let value: number;
            value = z80.regs.c;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x82: { // add a,d
            let value: number;
            value = z80.regs.d;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x83: { // add a,e
            let value: number;
            value = z80.regs.e;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x84: { // add a,h
            let value: number;
            value = z80.regs.h;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x85: { // add a,l
            let value: number;
            value = z80.regs.l;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x86: { // add a,(hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x87: { // add a,a
            let value: number;
            value = z80.regs.a;
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x88: { // adc a,b
            let value: number;
            value = z80.regs.b;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x89: { // adc a,c
            let value: number;
            value = z80.regs.c;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8A: { // adc a,d
            let value: number;
            value = z80.regs.d;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8B: { // adc a,e
            let value: number;
            value = z80.regs.e;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8C: { // adc a,h
            let value: number;
            value = z80.regs.h;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8D: { // adc a,l
            let value: number;
            value = z80.regs.l;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8E: { // adc a,(hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x8F: { // adc a,a
            let value: number;
            value = z80.regs.a;
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x90: { // sub a,b
            let value: number;
            value = z80.regs.b;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x91: { // sub a,c
            let value: number;
            value = z80.regs.c;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x92: { // sub a,d
            let value: number;
            value = z80.regs.d;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x93: { // sub a,e
            let value: number;
            value = z80.regs.e;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x94: { // sub a,h
            let value: number;
            value = z80.regs.h;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x95: { // sub a,l
            let value: number;
            value = z80.regs.l;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x96: { // sub a,(hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x97: { // sub a,a
            let value: number;
            value = z80.regs.a;
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x98: { // sbc a,b
            let value: number;
            value = z80.regs.b;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x99: { // sbc a,c
            let value: number;
            value = z80.regs.c;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9A: { // sbc a,d
            let value: number;
            value = z80.regs.d;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9B: { // sbc a,e
            let value: number;
            value = z80.regs.e;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9C: { // sbc a,h
            let value: number;
            value = z80.regs.h;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9D: { // sbc a,l
            let value: number;
            value = z80.regs.l;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9E: { // sbc a,(hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0x9F: { // sbc a,a
            let value: number;
            value = z80.regs.a;
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0xA0: { // and a,b
            let value: number;
            value = z80.regs.b;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA1: { // and a,c
            let value: number;
            value = z80.regs.c;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA2: { // and a,d
            let value: number;
            value = z80.regs.d;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA3: { // and a,e
            let value: number;
            value = z80.regs.e;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA4: { // and a,h
            let value: number;
            value = z80.regs.h;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA5: { // and a,l
            let value: number;
            value = z80.regs.l;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA6: { // and a,(hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA7: { // and a,a
            let value: number;
            value = z80.regs.a;
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xA8: { // xor a,b
            let value: number;
            value = z80.regs.b;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xA9: { // xor a,c
            let value: number;
            value = z80.regs.c;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAA: { // xor a,d
            let value: number;
            value = z80.regs.d;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAB: { // xor a,e
            let value: number;
            value = z80.regs.e;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAC: { // xor a,h
            let value: number;
            value = z80.regs.h;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAD: { // xor a,l
            let value: number;
            value = z80.regs.l;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAE: { // xor a,(hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xAF: { // xor a,a
            let value: number;
            value = z80.regs.a;
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB0: { // or a,b
            let value: number;
            value = z80.regs.b;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB1: { // or a,c
            let value: number;
            value = z80.regs.c;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB2: { // or a,d
            let value: number;
            value = z80.regs.d;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB3: { // or a,e
            let value: number;
            value = z80.regs.e;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB4: { // or a,h
            let value: number;
            value = z80.regs.h;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB5: { // or a,l
            let value: number;
            value = z80.regs.l;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB6: { // or a,(hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB7: { // or a,a
            let value: number;
            value = z80.regs.a;
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xB8: { // cp b
            let value: number;
            value = z80.regs.b;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xB9: { // cp c
            let value: number;
            value = z80.regs.c;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBA: { // cp d
            let value: number;
            value = z80.regs.d;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBB: { // cp e
            let value: number;
            value = z80.regs.e;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBC: { // cp h
            let value: number;
            value = z80.regs.h;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBD: { // cp l
            let value: number;
            value = z80.regs.l;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBE: { // cp (hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBF: { // cp a
            let value: number;
            value = z80.regs.a;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xC0: { // ret nz
            z80.incTStateCount(1);
            if ((z80.regs.f & Flag.Z) === 0) {
                z80.regs.pc = z80.popWord();
                z80.regs.memptr = z80.regs.pc;
            }
            break;
        }

        case 0xC1: { // pop bc
            z80.regs.bc = z80.popWord();
            break;
        }

        case 0xC2: { // jp nz,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.Z) === 0) {
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xC3: { // jp nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            break;
        }

        case 0xC4: { // call nz,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.Z) === 0) {
                z80.pushWord(z80.regs.pc);
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xC5: { // push bc
            z80.pushWord(z80.regs.bc);
            break;
        }

        case 0xC6: { // add a,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let result = add16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0xC7: { // rst 00
            z80.incTStateCount(1);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0000;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xC8: { // ret z
            z80.incTStateCount(1);
            if ((z80.regs.f & Flag.Z) !== 0) {
                z80.regs.pc = z80.popWord();
                z80.regs.memptr = z80.regs.pc;
            }
            break;
        }

        case 0xC9: { // ret
            z80.incTStateCount(1);
            z80.regs.pc = z80.popWord();
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xCA: { // jp z,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.Z) !== 0) {
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xCB: { // shift cb
            decodeCB(z80);
            break;
        }

        case 0xCC: { // call z,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.Z) !== 0) {
                z80.pushWord(z80.regs.pc);
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xCD: { // call nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            break;
        }

        case 0xCE: { // adc a,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let result = add16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | halfCarryAddTable[lookup & 0x07] | overflowAddTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0xCF: { // rst 8
            z80.incTStateCount(1);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0008;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xD0: { // ret nc
            z80.incTStateCount(1);
            if ((z80.regs.f & Flag.C) === 0) {
                z80.regs.pc = z80.popWord();
                z80.regs.memptr = z80.regs.pc;
            }
            break;
        }

        case 0xD1: { // pop de
            z80.regs.de = z80.popWord();
            break;
        }

        case 0xD2: { // jp nc,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.C) === 0) {
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xD3: { // out (nn),a
            const port = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc8(port));
            z80.writePort(word(z80.regs.a, port), z80.regs.a);
            break;
        }

        case 0xD4: { // call nc,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.C) === 0) {
                z80.pushWord(z80.regs.pc);
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xD5: { // push de
            z80.pushWord(z80.regs.de);
            break;
        }

        case 0xD6: { // sub a,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let result = sub16(z80.regs.a, value);
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0xD7: { // rst 10
            z80.incTStateCount(1);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0010;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xD8: { // ret c
            z80.incTStateCount(1);
            if ((z80.regs.f & Flag.C) !== 0) {
                z80.regs.pc = z80.popWord();
                z80.regs.memptr = z80.regs.pc;
            }
            break;
        }

        case 0xD9: { // exx
            break;
        }

        case 0xDA: { // jp c,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.C) !== 0) {
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xDB: { // in a,(nn)
            const port = word(z80.regs.a, z80.readByte(z80.regs.pc));
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.a = z80.readPort(port);
            z80.regs.memptr = inc16(port);
            break;
        }

        case 0xDC: { // call c,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.C) !== 0) {
                z80.pushWord(z80.regs.pc);
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xDD: { // shift dd
            decodeDD(z80);
            break;
        }

        case 0xDE: { // sbc a,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let result = sub16(z80.regs.a, value);
            if ((z80.regs.f & Flag.C) !== 0) {
                result = inc16(result);
            }
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((result & 0x88) >> 1)) & 0xFF;
            z80.regs.a = result & 0xFF;
            z80.regs.f = (((result & 0x100) !== 0) ? Flag.C : 0) | Flag.N | halfCarrySubTable[lookup & 0x07] | overflowSubTable[lookup >> 4] | z80.sz53Table[z80.regs.a];
            break;
        }

        case 0xDF: { // rst 18
            z80.incTStateCount(1);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0018;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xE0: { // ret po
            z80.incTStateCount(1);
            if ((z80.regs.f & Flag.P) === 0) {
                z80.regs.pc = z80.popWord();
                z80.regs.memptr = z80.regs.pc;
            }
            break;
        }

        case 0xE1: { // pop hl
            z80.regs.hl = z80.popWord();
            break;
        }

        case 0xE2: { // jp po,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.P) === 0) {
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xE3: { // ex (sp),hl
            const rightValue = z80.regs.hl;
            const leftValueL = z80.readByte(z80.regs.sp);
            const leftValueH = z80.readByte(inc16(z80.regs.sp));
            z80.incTStateCount(1);
            z80.writeByte(inc16(z80.regs.sp), hi(rightValue));
            z80.writeByte(z80.regs.sp, lo(rightValue));
            z80.incTStateCount(2);
            z80.regs.memptr = word(leftValueH, leftValueL);
            z80.regs.hl = word(leftValueH, leftValueL);
            break;
        }

        case 0xE4: { // call po,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.P) === 0) {
                z80.pushWord(z80.regs.pc);
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xE5: { // push hl
            z80.pushWord(z80.regs.hl);
            break;
        }

        case 0xE6: { // and nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.a &= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            z80.regs.f |= Flag.H;
            break;
        }

        case 0xE7: { // rst 20
            z80.incTStateCount(1);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0020;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xE8: { // ret pe
            z80.incTStateCount(1);
            if ((z80.regs.f & Flag.P) !== 0) {
                z80.regs.pc = z80.popWord();
                z80.regs.memptr = z80.regs.pc;
            }
            break;
        }

        case 0xE9: { // jp hl
            z80.regs.pc = z80.regs.hl;
            break;
        }

        case 0xEA: { // jp pe,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.P) !== 0) {
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xEB: { // ex de,hl
            const rightValue = z80.regs.hl;
            z80.regs.hl = z80.regs.de;
            z80.regs.de = rightValue;
            break;
        }

        case 0xEC: { // call pe,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.P) !== 0) {
                z80.pushWord(z80.regs.pc);
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xED: { // shift ed
            decodeED(z80);
            break;
        }

        case 0xEE: { // xor a,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.a ^= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xEF: { // rst 28
            z80.incTStateCount(1);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0028;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xF0: { // ret p
            z80.incTStateCount(1);
            if ((z80.regs.f & Flag.S) === 0) {
                z80.regs.pc = z80.popWord();
                z80.regs.memptr = z80.regs.pc;
            }
            break;
        }

        case 0xF1: { // pop af
            z80.regs.af = z80.popWord();
            break;
        }

        case 0xF2: { // jp p,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.S) === 0) {
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xF3: { // di
            z80.regs.iff1 = 0;
            z80.regs.iff2 = 0;
            break;
        }

        case 0xF4: { // call p,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.S) === 0) {
                z80.pushWord(z80.regs.pc);
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xF5: { // push af
            z80.pushWord(z80.regs.af);
            break;
        }

        case 0xF6: { // or nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.a |= value;
            z80.regs.f = z80.sz53pTable[z80.regs.a];
            break;
        }

        case 0xF7: { // rst 30
            z80.incTStateCount(1);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0030;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xF8: { // ret m
            z80.incTStateCount(1);
            if ((z80.regs.f & Flag.S) !== 0) {
                z80.regs.pc = z80.popWord();
                z80.regs.memptr = z80.regs.pc;
            }
            break;
        }

        case 0xF9: { // ld sp,hl
            let value: number;
            value = z80.regs.hl;
            z80.regs.sp = value;
            break;
        }

        case 0xFA: { // jp m,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.S) !== 0) {
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xFB: { // ei
            z80.regs.iff1 = 1;
            z80.regs.iff2 = 1;
            break;
        }

        case 0xFC: { // call m,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.S) !== 0) {
                z80.pushWord(z80.regs.pc);
                z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xFD: { // shift fd
            decodeFD(z80);
            break;
        }

        case 0xFE: { // cp nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xFF: { // rst 38
            z80.incTStateCount(1);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0038;
            z80.regs.memptr = z80.regs.pc;
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}
