// Do not modify. This file is generated by GenerateOpcodes.ts.

import {Z80} from "./Z80";
import {toHex, inc8, inc16, word, hi, lo, Flag} from "z80-test/dist";

const halfCarryAddTable = [0, Flag.H, Flag.H, Flag.H, 0, 0, 0, Flag.H];
const halfCarrySubTable = [0, 0, Flag.H, 0, Flag.H, 0, Flag.H, Flag.H];
const overflowAddTable = [0, 0, 0, Flag.V, Flag.V, 0, 0, 0];
const overflowSubTable = [0, Flag.V, 0, 0, 0, 0, Flag.V, 0];

export function decode(z80: Z80): void {
    z80.tStateCount += 4;
    const inst = z80.readByteInternal(z80.regs.pc);
    z80.regs.pc = (z80.regs.pc + 1) & 0xFFFF;
    z80.regs.r = (z80.regs.r + 1) & 0xFF;

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x00: { // nop
            break;
        }

        case 0x01: { // ld bc,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.bc = value;
            break;
        }

        case 0x02: { // ld (bc),a
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.bc));
            z80.writeByte(z80.regs.bc, value);
            break;
        }

        case 0x03: { // inc bc
            break;
        }

        case 0x04: { // inc b
            break;
        }

        case 0x05: { // dec b
            break;
        }

        case 0x06: { // ld b,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.b = value;
            break;
        }

        case 0x07: { // rlca
            break;
        }

        case 0x08: { // ex af,af'
            break;
        }

        case 0x09: { // add hl,bc
            break;
        }

        case 0x0A: { // ld a,(bc)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.bc);
            value = z80.readByte(z80.regs.bc);
            z80.regs.a = value;
            break;
        }

        case 0x0B: { // dec bc
            break;
        }

        case 0x0C: { // inc c
            break;
        }

        case 0x0D: { // dec c
            break;
        }

        case 0x0E: { // ld c,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.c = value;
            break;
        }

        case 0x0F: { // rrca
            break;
        }

        case 0x10: { // djnz offset
            break;
        }

        case 0x11: { // ld de,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.de = value;
            break;
        }

        case 0x12: { // ld (de),a
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.de));
            z80.writeByte(z80.regs.de, value);
            break;
        }

        case 0x13: { // inc de
            break;
        }

        case 0x14: { // inc d
            break;
        }

        case 0x15: { // dec d
            break;
        }

        case 0x16: { // ld d,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.d = value;
            break;
        }

        case 0x17: { // rla
            break;
        }

        case 0x18: { // jr offset
            break;
        }

        case 0x19: { // add hl,de
            break;
        }

        case 0x1A: { // ld a,(de)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.de);
            value = z80.readByte(z80.regs.de);
            z80.regs.a = value;
            break;
        }

        case 0x1B: { // dec de
            break;
        }

        case 0x1C: { // inc e
            break;
        }

        case 0x1D: { // dec e
            break;
        }

        case 0x1E: { // ld e,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.e = value;
            break;
        }

        case 0x1F: { // rra
            break;
        }

        case 0x20: { // jr nz,offset
            break;
        }

        case 0x21: { // ld hl,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.hl = value;
            break;
        }

        case 0x22: { // ld (nnnn),hl
            let value: number;
            value = z80.regs.hl;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x23: { // inc hl
            break;
        }

        case 0x24: { // inc h
            break;
        }

        case 0x25: { // dec h
            break;
        }

        case 0x26: { // ld h,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.h = value;
            break;
        }

        case 0x27: { // daa
            break;
        }

        case 0x28: { // jr z,offset
            break;
        }

        case 0x29: { // add hl,hl
            break;
        }

        case 0x2A: { // ld hl,(nnnn)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(value);
            z80.regs.memptr = inc16(value);
            z80.regs.hl = value;
            break;
        }

        case 0x2B: { // dec hl
            break;
        }

        case 0x2C: { // inc l
            break;
        }

        case 0x2D: { // dec l
            break;
        }

        case 0x2E: { // ld l,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.l = value;
            break;
        }

        case 0x2F: { // cpl
            break;
        }

        case 0x30: { // jr nc,offset
            break;
        }

        case 0x31: { // ld sp,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.sp = value;
            break;
        }

        case 0x32: { // ld (nnnn),a
            let value: number;
            value = z80.regs.a;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(value, z80.regs.a);
            break;
        }

        case 0x33: { // inc sp
            break;
        }

        case 0x34: { // inc (hl)
            break;
        }

        case 0x35: { // dec (hl)
            break;
        }

        case 0x36: { // ld (hl),nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x37: { // scf
            break;
        }

        case 0x38: { // jr c,offset
            break;
        }

        case 0x39: { // add hl,sp
            break;
        }

        case 0x3A: { // ld a,(nnnn)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(value);
            z80.regs.memptr = inc16(value);
            z80.regs.a = value;
            break;
        }

        case 0x3B: { // dec sp
            break;
        }

        case 0x3C: { // inc a
            break;
        }

        case 0x3D: { // dec a
            break;
        }

        case 0x3E: { // ld a,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.a = value;
            break;
        }

        case 0x3F: { // ccf
            break;
        }

        case 0x40: { // ld b,b
            let value: number;
            value = z80.regs.b;
            z80.regs.b = value;
            break;
        }

        case 0x41: { // ld b,c
            let value: number;
            value = z80.regs.c;
            z80.regs.b = value;
            break;
        }

        case 0x42: { // ld b,d
            let value: number;
            value = z80.regs.d;
            z80.regs.b = value;
            break;
        }

        case 0x43: { // ld b,e
            let value: number;
            value = z80.regs.e;
            z80.regs.b = value;
            break;
        }

        case 0x44: { // ld b,h
            let value: number;
            value = z80.regs.h;
            z80.regs.b = value;
            break;
        }

        case 0x45: { // ld b,l
            let value: number;
            value = z80.regs.l;
            z80.regs.b = value;
            break;
        }

        case 0x46: { // ld b,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.b = value;
            break;
        }

        case 0x47: { // ld b,a
            let value: number;
            value = z80.regs.a;
            z80.regs.b = value;
            break;
        }

        case 0x48: { // ld c,b
            let value: number;
            value = z80.regs.b;
            z80.regs.c = value;
            break;
        }

        case 0x49: { // ld c,c
            let value: number;
            value = z80.regs.c;
            z80.regs.c = value;
            break;
        }

        case 0x4A: { // ld c,d
            let value: number;
            value = z80.regs.d;
            z80.regs.c = value;
            break;
        }

        case 0x4B: { // ld c,e
            let value: number;
            value = z80.regs.e;
            z80.regs.c = value;
            break;
        }

        case 0x4C: { // ld c,h
            let value: number;
            value = z80.regs.h;
            z80.regs.c = value;
            break;
        }

        case 0x4D: { // ld c,l
            let value: number;
            value = z80.regs.l;
            z80.regs.c = value;
            break;
        }

        case 0x4E: { // ld c,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.c = value;
            break;
        }

        case 0x4F: { // ld c,a
            let value: number;
            value = z80.regs.a;
            z80.regs.c = value;
            break;
        }

        case 0x50: { // ld d,b
            let value: number;
            value = z80.regs.b;
            z80.regs.d = value;
            break;
        }

        case 0x51: { // ld d,c
            let value: number;
            value = z80.regs.c;
            z80.regs.d = value;
            break;
        }

        case 0x52: { // ld d,d
            let value: number;
            value = z80.regs.d;
            z80.regs.d = value;
            break;
        }

        case 0x53: { // ld d,e
            let value: number;
            value = z80.regs.e;
            z80.regs.d = value;
            break;
        }

        case 0x54: { // ld d,h
            let value: number;
            value = z80.regs.h;
            z80.regs.d = value;
            break;
        }

        case 0x55: { // ld d,l
            let value: number;
            value = z80.regs.l;
            z80.regs.d = value;
            break;
        }

        case 0x56: { // ld d,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.d = value;
            break;
        }

        case 0x57: { // ld d,a
            let value: number;
            value = z80.regs.a;
            z80.regs.d = value;
            break;
        }

        case 0x58: { // ld e,b
            let value: number;
            value = z80.regs.b;
            z80.regs.e = value;
            break;
        }

        case 0x59: { // ld e,c
            let value: number;
            value = z80.regs.c;
            z80.regs.e = value;
            break;
        }

        case 0x5A: { // ld e,d
            let value: number;
            value = z80.regs.d;
            z80.regs.e = value;
            break;
        }

        case 0x5B: { // ld e,e
            let value: number;
            value = z80.regs.e;
            z80.regs.e = value;
            break;
        }

        case 0x5C: { // ld e,h
            let value: number;
            value = z80.regs.h;
            z80.regs.e = value;
            break;
        }

        case 0x5D: { // ld e,l
            let value: number;
            value = z80.regs.l;
            z80.regs.e = value;
            break;
        }

        case 0x5E: { // ld e,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.e = value;
            break;
        }

        case 0x5F: { // ld e,a
            let value: number;
            value = z80.regs.a;
            z80.regs.e = value;
            break;
        }

        case 0x60: { // ld h,b
            let value: number;
            value = z80.regs.b;
            z80.regs.h = value;
            break;
        }

        case 0x61: { // ld h,c
            let value: number;
            value = z80.regs.c;
            z80.regs.h = value;
            break;
        }

        case 0x62: { // ld h,d
            let value: number;
            value = z80.regs.d;
            z80.regs.h = value;
            break;
        }

        case 0x63: { // ld h,e
            let value: number;
            value = z80.regs.e;
            z80.regs.h = value;
            break;
        }

        case 0x64: { // ld h,h
            let value: number;
            value = z80.regs.h;
            z80.regs.h = value;
            break;
        }

        case 0x65: { // ld h,l
            let value: number;
            value = z80.regs.l;
            z80.regs.h = value;
            break;
        }

        case 0x66: { // ld h,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.h = value;
            break;
        }

        case 0x67: { // ld h,a
            let value: number;
            value = z80.regs.a;
            z80.regs.h = value;
            break;
        }

        case 0x68: { // ld l,b
            let value: number;
            value = z80.regs.b;
            z80.regs.l = value;
            break;
        }

        case 0x69: { // ld l,c
            let value: number;
            value = z80.regs.c;
            z80.regs.l = value;
            break;
        }

        case 0x6A: { // ld l,d
            let value: number;
            value = z80.regs.d;
            z80.regs.l = value;
            break;
        }

        case 0x6B: { // ld l,e
            let value: number;
            value = z80.regs.e;
            z80.regs.l = value;
            break;
        }

        case 0x6C: { // ld l,h
            let value: number;
            value = z80.regs.h;
            z80.regs.l = value;
            break;
        }

        case 0x6D: { // ld l,l
            let value: number;
            value = z80.regs.l;
            z80.regs.l = value;
            break;
        }

        case 0x6E: { // ld l,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.l = value;
            break;
        }

        case 0x6F: { // ld l,a
            let value: number;
            value = z80.regs.a;
            z80.regs.l = value;
            break;
        }

        case 0x70: { // ld (hl),b
            let value: number;
            value = z80.regs.b;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x71: { // ld (hl),c
            let value: number;
            value = z80.regs.c;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x72: { // ld (hl),d
            let value: number;
            value = z80.regs.d;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x73: { // ld (hl),e
            let value: number;
            value = z80.regs.e;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x74: { // ld (hl),h
            let value: number;
            value = z80.regs.h;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x75: { // ld (hl),l
            let value: number;
            value = z80.regs.l;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x76: { // halt
            break;
        }

        case 0x77: { // ld (hl),a
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x78: { // ld a,b
            let value: number;
            value = z80.regs.b;
            z80.regs.a = value;
            break;
        }

        case 0x79: { // ld a,c
            let value: number;
            value = z80.regs.c;
            z80.regs.a = value;
            break;
        }

        case 0x7A: { // ld a,d
            let value: number;
            value = z80.regs.d;
            z80.regs.a = value;
            break;
        }

        case 0x7B: { // ld a,e
            let value: number;
            value = z80.regs.e;
            z80.regs.a = value;
            break;
        }

        case 0x7C: { // ld a,h
            let value: number;
            value = z80.regs.h;
            z80.regs.a = value;
            break;
        }

        case 0x7D: { // ld a,l
            let value: number;
            value = z80.regs.l;
            z80.regs.a = value;
            break;
        }

        case 0x7E: { // ld a,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.a = value;
            break;
        }

        case 0x7F: { // ld a,a
            let value: number;
            value = z80.regs.a;
            z80.regs.a = value;
            break;
        }

        case 0x80: { // add a,b
            break;
        }

        case 0x81: { // add a,c
            break;
        }

        case 0x82: { // add a,d
            break;
        }

        case 0x83: { // add a,e
            break;
        }

        case 0x84: { // add a,h
            break;
        }

        case 0x85: { // add a,l
            break;
        }

        case 0x86: { // add a,(hl)
            break;
        }

        case 0x87: { // add a,a
            break;
        }

        case 0x88: { // adc a,b
            break;
        }

        case 0x89: { // adc a,c
            break;
        }

        case 0x8A: { // adc a,d
            break;
        }

        case 0x8B: { // adc a,e
            break;
        }

        case 0x8C: { // adc a,h
            break;
        }

        case 0x8D: { // adc a,l
            break;
        }

        case 0x8E: { // adc a,(hl)
            break;
        }

        case 0x8F: { // adc a,a
            break;
        }

        case 0x90: { // sub a,b
            break;
        }

        case 0x91: { // sub a,c
            break;
        }

        case 0x92: { // sub a,d
            break;
        }

        case 0x93: { // sub a,e
            break;
        }

        case 0x94: { // sub a,h
            break;
        }

        case 0x95: { // sub a,l
            break;
        }

        case 0x96: { // sub a,(hl)
            break;
        }

        case 0x97: { // sub a,a
            break;
        }

        case 0x98: { // sbc a,b
            break;
        }

        case 0x99: { // sbc a,c
            break;
        }

        case 0x9A: { // sbc a,d
            break;
        }

        case 0x9B: { // sbc a,e
            break;
        }

        case 0x9C: { // sbc a,h
            break;
        }

        case 0x9D: { // sbc a,l
            break;
        }

        case 0x9E: { // sbc a,(hl)
            break;
        }

        case 0x9F: { // sbc a,a
            break;
        }

        case 0xA0: { // and a,b
            break;
        }

        case 0xA1: { // and a,c
            break;
        }

        case 0xA2: { // and a,d
            break;
        }

        case 0xA3: { // and a,e
            break;
        }

        case 0xA4: { // and a,h
            break;
        }

        case 0xA5: { // and a,l
            break;
        }

        case 0xA6: { // and a,(hl)
            break;
        }

        case 0xA7: { // and a,a
            break;
        }

        case 0xA8: { // xor a,b
            break;
        }

        case 0xA9: { // xor a,c
            break;
        }

        case 0xAA: { // xor a,d
            break;
        }

        case 0xAB: { // xor a,e
            break;
        }

        case 0xAC: { // xor a,h
            break;
        }

        case 0xAD: { // xor a,l
            break;
        }

        case 0xAE: { // xor a,(hl)
            break;
        }

        case 0xAF: { // xor a,a
            break;
        }

        case 0xB0: { // or a,b
            break;
        }

        case 0xB1: { // or a,c
            break;
        }

        case 0xB2: { // or a,d
            break;
        }

        case 0xB3: { // or a,e
            break;
        }

        case 0xB4: { // or a,h
            break;
        }

        case 0xB5: { // or a,l
            break;
        }

        case 0xB6: { // or a,(hl)
            break;
        }

        case 0xB7: { // or a,a
            break;
        }

        case 0xB8: { // cp b
            let value: number;
            value = z80.regs.b;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xB9: { // cp c
            let value: number;
            value = z80.regs.c;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBA: { // cp d
            let value: number;
            value = z80.regs.d;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBB: { // cp e
            let value: number;
            value = z80.regs.e;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBC: { // cp h
            let value: number;
            value = z80.regs.h;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBD: { // cp l
            let value: number;
            value = z80.regs.l;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBE: { // cp (hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBF: { // cp a
            let value: number;
            value = z80.regs.a;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xC0: { // ret nz
            break;
        }

        case 0xC1: { // pop bc
            break;
        }

        case 0xC2: { // jp nz,nnnn
            break;
        }

        case 0xC3: { // jp nnnn
            break;
        }

        case 0xC4: { // call nz,nnnn
            break;
        }

        case 0xC5: { // push bc
            break;
        }

        case 0xC6: { // add a,nn
            break;
        }

        case 0xC7: { // rst 00
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0000;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xC8: { // ret z
            break;
        }

        case 0xC9: { // ret
            break;
        }

        case 0xCA: { // jp z,nnnn
            break;
        }

        case 0xCB: { // shift cb
            break;
        }

        case 0xCC: { // call z,nnnn
            break;
        }

        case 0xCD: { // call nnnn
            break;
        }

        case 0xCE: { // adc a,nn
            break;
        }

        case 0xCF: { // rst 8
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0008;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xD0: { // ret nc
            break;
        }

        case 0xD1: { // pop de
            break;
        }

        case 0xD2: { // jp nc,nnnn
            break;
        }

        case 0xD3: { // out (nn),a
            break;
        }

        case 0xD4: { // call nc,nnnn
            break;
        }

        case 0xD5: { // push de
            break;
        }

        case 0xD6: { // sub nn
            break;
        }

        case 0xD7: { // rst 10
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0010;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xD8: { // ret c
            break;
        }

        case 0xD9: { // exx
            break;
        }

        case 0xDA: { // jp c,nnnn
            break;
        }

        case 0xDB: { // in a,(nn)
            break;
        }

        case 0xDC: { // call c,nnnn
            break;
        }

        case 0xDD: { // shift dd
            break;
        }

        case 0xDE: { // sbc a,nn
            break;
        }

        case 0xDF: { // rst 18
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0018;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xE0: { // ret po
            break;
        }

        case 0xE1: { // pop hl
            break;
        }

        case 0xE2: { // jp po,nnnn
            break;
        }

        case 0xE3: { // ex (sp),hl
            break;
        }

        case 0xE4: { // call po,nnnn
            break;
        }

        case 0xE5: { // push hl
            break;
        }

        case 0xE6: { // and nn
            break;
        }

        case 0xE7: { // rst 20
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0020;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xE8: { // ret pe
            break;
        }

        case 0xE9: { // jp hl
            break;
        }

        case 0xEA: { // jp pe,nnnn
            break;
        }

        case 0xEB: { // ex de,hl
            break;
        }

        case 0xEC: { // call pe,nnnn
            break;
        }

        case 0xED: { // shift ed
            break;
        }

        case 0xEE: { // xor a,nn
            break;
        }

        case 0xEF: { // rst 28
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0028;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xF0: { // ret p
            break;
        }

        case 0xF1: { // pop af
            break;
        }

        case 0xF2: { // jp p,nnnn
            break;
        }

        case 0xF3: { // di
            break;
        }

        case 0xF4: { // call p,nnnn
            break;
        }

        case 0xF5: { // push af
            break;
        }

        case 0xF6: { // or nn
            break;
        }

        case 0xF7: { // rst 30
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0030;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xF8: { // ret m
            break;
        }

        case 0xF9: { // ld sp,hl
            let value: number;
            value = z80.regs.hl;
            z80.regs.sp = value;
            break;
        }

        case 0xFA: { // jp m,nnnn
            break;
        }

        case 0xFB: { // ei
            break;
        }

        case 0xFC: { // call m,nnnn
            break;
        }

        case 0xFD: { // shift fd
            break;
        }

        case 0xFE: { // cp nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xFF: { // rst 38
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0038;
            z80.regs.memptr = z80.regs.pc;
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}
