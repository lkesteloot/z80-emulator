// Do not modify. This file is generated by GenerateOpcodes.ts.

import {Z80} from "./Z80";
import {toHex, inc8, inc16, word, hi, lo, Flag, signedByte} from "z80-test/dist";

const halfCarryAddTable = [0, Flag.H, Flag.H, Flag.H, 0, 0, 0, Flag.H];
const halfCarrySubTable = [0, 0, Flag.H, 0, Flag.H, 0, Flag.H, Flag.H];
const overflowAddTable = [0, 0, 0, Flag.V, Flag.V, 0, 0, 0];
const overflowSubTable = [0, Flag.V, 0, 0, 0, 0, Flag.V, 0];

function fetchInstruction(z80: Z80): number {
    z80.tStateCount += 4;
    const inst = z80.readByteInternal(z80.regs.pc);
    z80.regs.pc = (z80.regs.pc + 1) & 0xFFFF;
    z80.regs.r = (z80.regs.r + 1) & 0xFF;

    return inst;
}

function decodeCB(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        // DECODE_CB

        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeDD(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x09: { // add ix,bc
            break;
        }

        case 0x19: { // add ix,de
            break;
        }

        case 0x21: { // ld ix,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.ix = value;
            break;
        }

        case 0x22: { // ld (nnnn),ix
            let value: number;
            value = z80.regs.ix;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x23: { // inc ix
            break;
        }

        case 0x24: { // inc ixh
            break;
        }

        case 0x25: { // dec ixh
            break;
        }

        case 0x26: { // ld ixh,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.ixh = value;
            break;
        }

        case 0x29: { // add ix,ix
            break;
        }

        case 0x2A: { // ld ix,(nnnn)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(value);
            z80.regs.memptr = inc16(value);
            z80.regs.ix = value;
            break;
        }

        case 0x2B: { // dec ix
            break;
        }

        case 0x2C: { // inc ixl
            break;
        }

        case 0x2D: { // dec ixl
            break;
        }

        case 0x2E: { // ld ixl,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.ixl = value;
            break;
        }

        case 0x34: { // inc (ix+dd)
            break;
        }

        case 0x35: { // dec (ix+dd)
            break;
        }

        case 0x36: { // ld (ix+dd),nn
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x39: { // add ix,sp
            break;
        }

        case 0x44: { // ld b,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.b = value;
            break;
        }

        case 0x45: { // ld b,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.b = value;
            break;
        }

        case 0x46: { // ld b,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.b = value;
            break;
        }

        case 0x4C: { // ld c,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.c = value;
            break;
        }

        case 0x4D: { // ld c,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.c = value;
            break;
        }

        case 0x4E: { // ld c,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.c = value;
            break;
        }

        case 0x54: { // ld d,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.d = value;
            break;
        }

        case 0x55: { // ld d,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.d = value;
            break;
        }

        case 0x56: { // ld d,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.d = value;
            break;
        }

        case 0x5C: { // ld e,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.e = value;
            break;
        }

        case 0x5D: { // ld e,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.e = value;
            break;
        }

        case 0x5E: { // ld e,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.e = value;
            break;
        }

        case 0x60: { // ld ixh,b
            let value: number;
            value = z80.regs.b;
            z80.regs.ixh = value;
            break;
        }

        case 0x61: { // ld ixh,c
            let value: number;
            value = z80.regs.c;
            z80.regs.ixh = value;
            break;
        }

        case 0x62: { // ld ixh,d
            let value: number;
            value = z80.regs.d;
            z80.regs.ixh = value;
            break;
        }

        case 0x63: { // ld ixh,e
            let value: number;
            value = z80.regs.e;
            z80.regs.ixh = value;
            break;
        }

        case 0x64: { // ld ixh,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.ixh = value;
            break;
        }

        case 0x65: { // ld ixh,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.ixh = value;
            break;
        }

        case 0x66: { // ld h,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.h = value;
            break;
        }

        case 0x67: { // ld ixh,a
            let value: number;
            value = z80.regs.a;
            z80.regs.ixh = value;
            break;
        }

        case 0x68: { // ld ixl,b
            let value: number;
            value = z80.regs.b;
            z80.regs.ixl = value;
            break;
        }

        case 0x69: { // ld ixl,c
            let value: number;
            value = z80.regs.c;
            z80.regs.ixl = value;
            break;
        }

        case 0x6A: { // ld ixl,d
            let value: number;
            value = z80.regs.d;
            z80.regs.ixl = value;
            break;
        }

        case 0x6B: { // ld ixl,e
            let value: number;
            value = z80.regs.e;
            z80.regs.ixl = value;
            break;
        }

        case 0x6C: { // ld ixl,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.ixl = value;
            break;
        }

        case 0x6D: { // ld ixl,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.ixl = value;
            break;
        }

        case 0x6E: { // ld l,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.l = value;
            break;
        }

        case 0x6F: { // ld ixl,a
            let value: number;
            value = z80.regs.a;
            z80.regs.ixl = value;
            break;
        }

        case 0x70: { // ld (ix+dd),b
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.b;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x71: { // ld (ix+dd),c
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.c;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x72: { // ld (ix+dd),d
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.d;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x73: { // ld (ix+dd),e
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.e;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x74: { // ld (ix+dd),h
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.h;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x75: { // ld (ix+dd),l
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.l;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x77: { // ld (ix+dd),a
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = (z80.regs.ix + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x7C: { // ld a,ixh
            let value: number;
            value = z80.regs.ixh;
            z80.regs.a = value;
            break;
        }

        case 0x7D: { // ld a,ixl
            let value: number;
            value = z80.regs.ixl;
            z80.regs.a = value;
            break;
        }

        case 0x7E: { // ld a,(ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a = value;
            break;
        }

        case 0x84: { // add a,ixh
            break;
        }

        case 0x85: { // add a,ixl
            break;
        }

        case 0x86: { // add a,(ix+dd)
            break;
        }

        case 0x8C: { // adc a,ixh
            break;
        }

        case 0x8D: { // adc a,ixl
            break;
        }

        case 0x8E: { // adc a,(ix+dd)
            break;
        }

        case 0x94: { // sub a,ixh
            break;
        }

        case 0x95: { // sub a,ixl
            break;
        }

        case 0x96: { // sub a,(ix+dd)
            break;
        }

        case 0x9C: { // sbc a,ixh
            break;
        }

        case 0x9D: { // sbc a,ixl
            break;
        }

        case 0x9E: { // sbc a,(ix+dd)
            break;
        }

        case 0xA4: { // and a,ixh
            break;
        }

        case 0xA5: { // and a,ixl
            break;
        }

        case 0xA6: { // and a,(ix+dd)
            break;
        }

        case 0xAC: { // xor a,ixh
            break;
        }

        case 0xAD: { // xor a,ixl
            break;
        }

        case 0xAE: { // xor a,(ix+dd)
            break;
        }

        case 0xB4: { // or a,ixh
            break;
        }

        case 0xB5: { // or a,ixl
            break;
        }

        case 0xB6: { // or a,(ix+dd)
            break;
        }

        case 0xBC: { // cp ixh
            let value: number;
            value = z80.regs.ixh;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBD: { // cp ixl
            let value: number;
            value = z80.regs.ixl;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBE: { // cp (ix+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.ix + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xCB: { // shift ddcb
            decodeDDCB(z80);
            break;
        }

        case 0xE1: { // pop ix
            z80.regs.ix = z80.popWord();
            break;
        }

        case 0xE3: { // ex (sp),ix
            const rightValue = z80.regs.ix;
            const leftValueL = z80.readByte(z80.regs.sp);
            const leftValueH = z80.readByte(inc16(z80.regs.sp));
            z80.tStateCount += 1;
            z80.writeByte(inc16(z80.regs.sp), hi(rightValue));
            z80.writeByte(z80.regs.sp, lo(rightValue));
            z80.tStateCount += 2;
            z80.regs.memptr = word(leftValueH, leftValueL);
            z80.regs.ix = word(leftValueH, leftValueL);
            break;
        }

        case 0xE5: { // push ix
            z80.pushWord(z80.regs.ix);
            break;
        }

        case 0xE9: { // jp ix
            z80.regs.pc = z80.regs.ix;
            break;
        }

        case 0xF9: { // ld sp,ix
            let value: number;
            value = z80.regs.ix;
            z80.regs.sp = value;
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeDDCB(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x00: { // ld b,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x01: { // ld c,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x02: { // ld d,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x03: { // ld e,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x04: { // ld h,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x05: { // ld l,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x06: { // rlc (ix+dd)
            break;
        }

        case 0x07: { // ld a,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x08: { // ld b,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x09: { // ld c,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0A: { // ld d,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0B: { // ld e,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0C: { // ld h,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0D: { // ld l,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0E: { // rrc (ix+dd)
            break;
        }

        case 0x0F: { // ld a,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x10: { // ld b,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x11: { // ld c,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x12: { // ld d,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x13: { // ld e,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x14: { // ld h,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x15: { // ld l,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x16: { // rl (ix+dd)
            break;
        }

        case 0x17: { // ld a,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x18: { // ld b,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x19: { // ld c,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1A: { // ld d,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1B: { // ld e,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1C: { // ld h,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1D: { // ld l,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1E: { // rr (ix+dd)
            break;
        }

        case 0x1F: { // ld a,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x20: { // ld b,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x21: { // ld c,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x22: { // ld d,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x23: { // ld e,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x24: { // ld h,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x25: { // ld l,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x26: { // sla (ix+dd)
            break;
        }

        case 0x27: { // ld a,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x28: { // ld b,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x29: { // ld c,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2A: { // ld d,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2B: { // ld e,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2C: { // ld h,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2D: { // ld l,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2E: { // sra (ix+dd)
            break;
        }

        case 0x2F: { // ld a,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x30: { // ld b,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x31: { // ld c,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x32: { // ld d,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x33: { // ld e,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x34: { // ld h,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x35: { // ld l,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x36: { // sll (ix+dd)
            break;
        }

        case 0x37: { // ld a,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x38: { // ld b,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x39: { // ld c,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3A: { // ld d,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3B: { // ld e,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3C: { // ld h,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3D: { // ld l,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3E: { // srl (ix+dd)
            break;
        }

        case 0x3F: { // ld a,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x40: { // 
            // Undefined opcode.
            break;
        }

        case 0x41: { // 
            // Undefined opcode.
            break;
        }

        case 0x42: { // 
            // Undefined opcode.
            break;
        }

        case 0x43: { // 
            // Undefined opcode.
            break;
        }

        case 0x44: { // 
            // Undefined opcode.
            break;
        }

        case 0x45: { // 
            // Undefined opcode.
            break;
        }

        case 0x46: { // 
            // Undefined opcode.
            break;
        }

        case 0x47: { // bit 0,(ix+dd)
            break;
        }

        case 0x48: { // 
            // Undefined opcode.
            break;
        }

        case 0x49: { // 
            // Undefined opcode.
            break;
        }

        case 0x4A: { // 
            // Undefined opcode.
            break;
        }

        case 0x4B: { // 
            // Undefined opcode.
            break;
        }

        case 0x4C: { // 
            // Undefined opcode.
            break;
        }

        case 0x4D: { // 
            // Undefined opcode.
            break;
        }

        case 0x4E: { // 
            // Undefined opcode.
            break;
        }

        case 0x4F: { // bit 1,(ix+dd)
            break;
        }

        case 0x50: { // 
            // Undefined opcode.
            break;
        }

        case 0x51: { // 
            // Undefined opcode.
            break;
        }

        case 0x52: { // 
            // Undefined opcode.
            break;
        }

        case 0x53: { // 
            // Undefined opcode.
            break;
        }

        case 0x54: { // 
            // Undefined opcode.
            break;
        }

        case 0x55: { // 
            // Undefined opcode.
            break;
        }

        case 0x56: { // 
            // Undefined opcode.
            break;
        }

        case 0x57: { // bit 2,(ix+dd)
            break;
        }

        case 0x58: { // 
            // Undefined opcode.
            break;
        }

        case 0x59: { // 
            // Undefined opcode.
            break;
        }

        case 0x5A: { // 
            // Undefined opcode.
            break;
        }

        case 0x5B: { // 
            // Undefined opcode.
            break;
        }

        case 0x5C: { // 
            // Undefined opcode.
            break;
        }

        case 0x5D: { // 
            // Undefined opcode.
            break;
        }

        case 0x5E: { // 
            // Undefined opcode.
            break;
        }

        case 0x5F: { // bit 3,(ix+dd)
            break;
        }

        case 0x60: { // 
            // Undefined opcode.
            break;
        }

        case 0x61: { // 
            // Undefined opcode.
            break;
        }

        case 0x62: { // 
            // Undefined opcode.
            break;
        }

        case 0x63: { // 
            // Undefined opcode.
            break;
        }

        case 0x64: { // 
            // Undefined opcode.
            break;
        }

        case 0x65: { // 
            // Undefined opcode.
            break;
        }

        case 0x66: { // 
            // Undefined opcode.
            break;
        }

        case 0x67: { // bit 4,(ix+dd)
            break;
        }

        case 0x68: { // 
            // Undefined opcode.
            break;
        }

        case 0x69: { // 
            // Undefined opcode.
            break;
        }

        case 0x6A: { // 
            // Undefined opcode.
            break;
        }

        case 0x6B: { // 
            // Undefined opcode.
            break;
        }

        case 0x6C: { // 
            // Undefined opcode.
            break;
        }

        case 0x6D: { // 
            // Undefined opcode.
            break;
        }

        case 0x6E: { // 
            // Undefined opcode.
            break;
        }

        case 0x6F: { // bit 5,(ix+dd)
            break;
        }

        case 0x70: { // 
            // Undefined opcode.
            break;
        }

        case 0x71: { // 
            // Undefined opcode.
            break;
        }

        case 0x72: { // 
            // Undefined opcode.
            break;
        }

        case 0x73: { // 
            // Undefined opcode.
            break;
        }

        case 0x74: { // 
            // Undefined opcode.
            break;
        }

        case 0x75: { // 
            // Undefined opcode.
            break;
        }

        case 0x76: { // 
            // Undefined opcode.
            break;
        }

        case 0x77: { // bit 6,(ix+dd)
            break;
        }

        case 0x78: { // 
            // Undefined opcode.
            break;
        }

        case 0x79: { // 
            // Undefined opcode.
            break;
        }

        case 0x7A: { // 
            // Undefined opcode.
            break;
        }

        case 0x7B: { // 
            // Undefined opcode.
            break;
        }

        case 0x7C: { // 
            // Undefined opcode.
            break;
        }

        case 0x7D: { // 
            // Undefined opcode.
            break;
        }

        case 0x7E: { // 
            // Undefined opcode.
            break;
        }

        case 0x7F: { // bit 7,(ix+dd)
            break;
        }

        case 0x80: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x81: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x82: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x83: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x84: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x85: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x86: { // res 0,(ix+dd)
            break;
        }

        case 0x87: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x88: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x89: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8A: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8B: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8C: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8D: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8E: { // res 1,(ix+dd)
            break;
        }

        case 0x8F: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x90: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x91: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x92: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x93: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x94: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x95: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x96: { // res 2,(ix+dd)
            break;
        }

        case 0x97: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x98: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x99: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9A: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9B: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9C: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9D: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9E: { // res 3,(ix+dd)
            break;
        }

        case 0x9F: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA0: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA1: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA2: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA3: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA4: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA5: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA6: { // res 4,(ix+dd)
            break;
        }

        case 0xA7: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA8: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA9: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAA: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAB: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAC: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAD: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAE: { // res 5,(ix+dd)
            break;
        }

        case 0xAF: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB0: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB1: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB2: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB3: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB4: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB5: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB6: { // res 6,(ix+dd)
            break;
        }

        case 0xB7: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB8: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB9: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBA: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBB: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBC: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBD: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBE: { // res 7,(ix+dd)
            break;
        }

        case 0xBF: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC6: { // set 0,(ix+dd)
            break;
        }

        case 0xC7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCE: { // set 1,(ix+dd)
            break;
        }

        case 0xCF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD6: { // set 2,(ix+dd)
            break;
        }

        case 0xD7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDE: { // set 3,(ix+dd)
            break;
        }

        case 0xDF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE6: { // set 4,(ix+dd)
            break;
        }

        case 0xE7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xED: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEE: { // set 5,(ix+dd)
            break;
        }

        case 0xEF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF6: { // set 6,(ix+dd)
            break;
        }

        case 0xF7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFE: { // set 7,(ix+dd)
            break;
        }

        case 0xFF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeED(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        // DECODE_ED

        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeFD(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x09: { // add iy,bc
            break;
        }

        case 0x19: { // add iy,de
            break;
        }

        case 0x21: { // ld iy,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.iy = value;
            break;
        }

        case 0x22: { // ld (nnnn),iy
            let value: number;
            value = z80.regs.iy;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x23: { // inc iy
            break;
        }

        case 0x24: { // inc iyh
            break;
        }

        case 0x25: { // dec iyh
            break;
        }

        case 0x26: { // ld iyh,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.iyh = value;
            break;
        }

        case 0x29: { // add iy,iy
            break;
        }

        case 0x2A: { // ld iy,(nnnn)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(value);
            z80.regs.memptr = inc16(value);
            z80.regs.iy = value;
            break;
        }

        case 0x2B: { // dec iy
            break;
        }

        case 0x2C: { // inc iyl
            break;
        }

        case 0x2D: { // dec iyl
            break;
        }

        case 0x2E: { // ld iyl,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.iyl = value;
            break;
        }

        case 0x34: { // inc (iy+dd)
            break;
        }

        case 0x35: { // dec (iy+dd)
            break;
        }

        case 0x36: { // ld (iy+dd),nn
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x39: { // add iy,sp
            break;
        }

        case 0x44: { // ld b,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.b = value;
            break;
        }

        case 0x45: { // ld b,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.b = value;
            break;
        }

        case 0x46: { // ld b,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.b = value;
            break;
        }

        case 0x4C: { // ld c,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.c = value;
            break;
        }

        case 0x4D: { // ld c,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.c = value;
            break;
        }

        case 0x4E: { // ld c,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.c = value;
            break;
        }

        case 0x54: { // ld d,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.d = value;
            break;
        }

        case 0x55: { // ld d,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.d = value;
            break;
        }

        case 0x56: { // ld d,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.d = value;
            break;
        }

        case 0x5C: { // ld e,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.e = value;
            break;
        }

        case 0x5D: { // ld e,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.e = value;
            break;
        }

        case 0x5E: { // ld e,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.e = value;
            break;
        }

        case 0x60: { // ld iyh,b
            let value: number;
            value = z80.regs.b;
            z80.regs.iyh = value;
            break;
        }

        case 0x61: { // ld iyh,c
            let value: number;
            value = z80.regs.c;
            z80.regs.iyh = value;
            break;
        }

        case 0x62: { // ld iyh,d
            let value: number;
            value = z80.regs.d;
            z80.regs.iyh = value;
            break;
        }

        case 0x63: { // ld iyh,e
            let value: number;
            value = z80.regs.e;
            z80.regs.iyh = value;
            break;
        }

        case 0x64: { // ld iyh,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.iyh = value;
            break;
        }

        case 0x65: { // ld iyh,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.iyh = value;
            break;
        }

        case 0x66: { // ld h,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.h = value;
            break;
        }

        case 0x67: { // ld iyh,a
            let value: number;
            value = z80.regs.a;
            z80.regs.iyh = value;
            break;
        }

        case 0x68: { // ld iyl,b
            let value: number;
            value = z80.regs.b;
            z80.regs.iyl = value;
            break;
        }

        case 0x69: { // ld iyl,c
            let value: number;
            value = z80.regs.c;
            z80.regs.iyl = value;
            break;
        }

        case 0x6A: { // ld iyl,d
            let value: number;
            value = z80.regs.d;
            z80.regs.iyl = value;
            break;
        }

        case 0x6B: { // ld iyl,e
            let value: number;
            value = z80.regs.e;
            z80.regs.iyl = value;
            break;
        }

        case 0x6C: { // ld iyl,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.iyl = value;
            break;
        }

        case 0x6D: { // ld iyl,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.iyl = value;
            break;
        }

        case 0x6E: { // ld l,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.l = value;
            break;
        }

        case 0x6F: { // ld iyl,a
            let value: number;
            value = z80.regs.a;
            z80.regs.iyl = value;
            break;
        }

        case 0x70: { // ld (iy+dd),b
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.b;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x71: { // ld (iy+dd),c
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.c;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x72: { // ld (iy+dd),d
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.d;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x73: { // ld (iy+dd),e
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.e;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x74: { // ld (iy+dd),h
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.h;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x75: { // ld (iy+dd),l
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.l;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x77: { // ld (iy+dd),a
            const dd = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = (z80.regs.iy + signedByte(dd)) & 0xFFFF;
            z80.writeByte(z80.regs.memptr, value);
            break;
        }

        case 0x7C: { // ld a,iyh
            let value: number;
            value = z80.regs.iyh;
            z80.regs.a = value;
            break;
        }

        case 0x7D: { // ld a,iyl
            let value: number;
            value = z80.regs.iyl;
            z80.regs.a = value;
            break;
        }

        case 0x7E: { // ld a,(iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            z80.regs.a = value;
            break;
        }

        case 0x84: { // add a,iyh
            break;
        }

        case 0x85: { // add a,iyl
            break;
        }

        case 0x86: { // add a,(iy+dd)
            break;
        }

        case 0x8C: { // adc a,iyh
            break;
        }

        case 0x8D: { // adc a,iyl
            break;
        }

        case 0x8E: { // adc a,(iy+dd)
            break;
        }

        case 0x94: { // sub a,iyh
            break;
        }

        case 0x95: { // sub a,iyl
            break;
        }

        case 0x96: { // sub a,(iy+dd)
            break;
        }

        case 0x9C: { // sbc a,iyh
            break;
        }

        case 0x9D: { // sbc a,iyl
            break;
        }

        case 0x9E: { // sbc a,(iy+dd)
            break;
        }

        case 0xA4: { // and a,iyh
            break;
        }

        case 0xA5: { // and a,iyl
            break;
        }

        case 0xA6: { // and a,(iy+dd)
            break;
        }

        case 0xAC: { // xor a,iyh
            break;
        }

        case 0xAD: { // xor a,iyl
            break;
        }

        case 0xAE: { // xor a,(iy+dd)
            break;
        }

        case 0xB4: { // or a,iyh
            break;
        }

        case 0xB5: { // or a,iyl
            break;
        }

        case 0xB6: { // or a,(iy+dd)
            break;
        }

        case 0xBC: { // cp iyh
            let value: number;
            value = z80.regs.iyh;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBD: { // cp iyl
            let value: number;
            value = z80.regs.iyl;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBE: { // cp (iy+dd)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = (z80.regs.iy + signedByte(value)) & 0xFFFF;
            value = z80.readByte(z80.regs.memptr);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xCB: { // shift fdcb
            decodeFDCB(z80);
            break;
        }

        case 0xE1: { // pop iy
            z80.regs.iy = z80.popWord();
            break;
        }

        case 0xE3: { // ex (sp),iy
            const rightValue = z80.regs.iy;
            const leftValueL = z80.readByte(z80.regs.sp);
            const leftValueH = z80.readByte(inc16(z80.regs.sp));
            z80.tStateCount += 1;
            z80.writeByte(inc16(z80.regs.sp), hi(rightValue));
            z80.writeByte(z80.regs.sp, lo(rightValue));
            z80.tStateCount += 2;
            z80.regs.memptr = word(leftValueH, leftValueL);
            z80.regs.iy = word(leftValueH, leftValueL);
            break;
        }

        case 0xE5: { // push iy
            z80.pushWord(z80.regs.iy);
            break;
        }

        case 0xE9: { // jp iy
            z80.regs.pc = z80.regs.iy;
            break;
        }

        case 0xF9: { // ld sp,iy
            let value: number;
            value = z80.regs.iy;
            z80.regs.sp = value;
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

function decodeFDCB(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x00: { // ld b,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x01: { // ld c,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x02: { // ld d,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x03: { // ld e,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x04: { // ld h,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x05: { // ld l,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x06: { // rlc (iy+dd)
            break;
        }

        case 0x07: { // ld a,rlc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x08: { // ld b,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x09: { // ld c,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0A: { // ld d,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0B: { // ld e,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0C: { // ld h,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0D: { // ld l,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x0E: { // rrc (iy+dd)
            break;
        }

        case 0x0F: { // ld a,rrc
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x10: { // ld b,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x11: { // ld c,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x12: { // ld d,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x13: { // ld e,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x14: { // ld h,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x15: { // ld l,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x16: { // rl (iy+dd)
            break;
        }

        case 0x17: { // ld a,rl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x18: { // ld b,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x19: { // ld c,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1A: { // ld d,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1B: { // ld e,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1C: { // ld h,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1D: { // ld l,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x1E: { // rr (iy+dd)
            break;
        }

        case 0x1F: { // ld a,rr
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x20: { // ld b,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x21: { // ld c,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x22: { // ld d,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x23: { // ld e,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x24: { // ld h,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x25: { // ld l,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x26: { // sla (iy+dd)
            break;
        }

        case 0x27: { // ld a,sla
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x28: { // ld b,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x29: { // ld c,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2A: { // ld d,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2B: { // ld e,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2C: { // ld h,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2D: { // ld l,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x2E: { // sra (iy+dd)
            break;
        }

        case 0x2F: { // ld a,sra
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x30: { // ld b,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x31: { // ld c,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x32: { // ld d,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x33: { // ld e,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x34: { // ld h,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x35: { // ld l,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x36: { // sll (iy+dd)
            break;
        }

        case 0x37: { // ld a,sll
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x38: { // ld b,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x39: { // ld c,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3A: { // ld d,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3B: { // ld e,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3C: { // ld h,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3D: { // ld l,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x3E: { // srl (iy+dd)
            break;
        }

        case 0x3F: { // ld a,srl
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x40: { // 
            // Undefined opcode.
            break;
        }

        case 0x41: { // 
            // Undefined opcode.
            break;
        }

        case 0x42: { // 
            // Undefined opcode.
            break;
        }

        case 0x43: { // 
            // Undefined opcode.
            break;
        }

        case 0x44: { // 
            // Undefined opcode.
            break;
        }

        case 0x45: { // 
            // Undefined opcode.
            break;
        }

        case 0x46: { // 
            // Undefined opcode.
            break;
        }

        case 0x47: { // bit 0,(iy+dd)
            break;
        }

        case 0x48: { // 
            // Undefined opcode.
            break;
        }

        case 0x49: { // 
            // Undefined opcode.
            break;
        }

        case 0x4A: { // 
            // Undefined opcode.
            break;
        }

        case 0x4B: { // 
            // Undefined opcode.
            break;
        }

        case 0x4C: { // 
            // Undefined opcode.
            break;
        }

        case 0x4D: { // 
            // Undefined opcode.
            break;
        }

        case 0x4E: { // 
            // Undefined opcode.
            break;
        }

        case 0x4F: { // bit 1,(iy+dd)
            break;
        }

        case 0x50: { // 
            // Undefined opcode.
            break;
        }

        case 0x51: { // 
            // Undefined opcode.
            break;
        }

        case 0x52: { // 
            // Undefined opcode.
            break;
        }

        case 0x53: { // 
            // Undefined opcode.
            break;
        }

        case 0x54: { // 
            // Undefined opcode.
            break;
        }

        case 0x55: { // 
            // Undefined opcode.
            break;
        }

        case 0x56: { // 
            // Undefined opcode.
            break;
        }

        case 0x57: { // bit 2,(iy+dd)
            break;
        }

        case 0x58: { // 
            // Undefined opcode.
            break;
        }

        case 0x59: { // 
            // Undefined opcode.
            break;
        }

        case 0x5A: { // 
            // Undefined opcode.
            break;
        }

        case 0x5B: { // 
            // Undefined opcode.
            break;
        }

        case 0x5C: { // 
            // Undefined opcode.
            break;
        }

        case 0x5D: { // 
            // Undefined opcode.
            break;
        }

        case 0x5E: { // 
            // Undefined opcode.
            break;
        }

        case 0x5F: { // bit 3,(iy+dd)
            break;
        }

        case 0x60: { // 
            // Undefined opcode.
            break;
        }

        case 0x61: { // 
            // Undefined opcode.
            break;
        }

        case 0x62: { // 
            // Undefined opcode.
            break;
        }

        case 0x63: { // 
            // Undefined opcode.
            break;
        }

        case 0x64: { // 
            // Undefined opcode.
            break;
        }

        case 0x65: { // 
            // Undefined opcode.
            break;
        }

        case 0x66: { // 
            // Undefined opcode.
            break;
        }

        case 0x67: { // bit 4,(iy+dd)
            break;
        }

        case 0x68: { // 
            // Undefined opcode.
            break;
        }

        case 0x69: { // 
            // Undefined opcode.
            break;
        }

        case 0x6A: { // 
            // Undefined opcode.
            break;
        }

        case 0x6B: { // 
            // Undefined opcode.
            break;
        }

        case 0x6C: { // 
            // Undefined opcode.
            break;
        }

        case 0x6D: { // 
            // Undefined opcode.
            break;
        }

        case 0x6E: { // 
            // Undefined opcode.
            break;
        }

        case 0x6F: { // bit 5,(iy+dd)
            break;
        }

        case 0x70: { // 
            // Undefined opcode.
            break;
        }

        case 0x71: { // 
            // Undefined opcode.
            break;
        }

        case 0x72: { // 
            // Undefined opcode.
            break;
        }

        case 0x73: { // 
            // Undefined opcode.
            break;
        }

        case 0x74: { // 
            // Undefined opcode.
            break;
        }

        case 0x75: { // 
            // Undefined opcode.
            break;
        }

        case 0x76: { // 
            // Undefined opcode.
            break;
        }

        case 0x77: { // bit 6,(iy+dd)
            break;
        }

        case 0x78: { // 
            // Undefined opcode.
            break;
        }

        case 0x79: { // 
            // Undefined opcode.
            break;
        }

        case 0x7A: { // 
            // Undefined opcode.
            break;
        }

        case 0x7B: { // 
            // Undefined opcode.
            break;
        }

        case 0x7C: { // 
            // Undefined opcode.
            break;
        }

        case 0x7D: { // 
            // Undefined opcode.
            break;
        }

        case 0x7E: { // 
            // Undefined opcode.
            break;
        }

        case 0x7F: { // bit 7,(iy+dd)
            break;
        }

        case 0x80: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x81: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x82: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x83: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x84: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x85: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x86: { // res 0,(iy+dd)
            break;
        }

        case 0x87: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x88: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x89: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8A: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8B: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8C: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8D: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x8E: { // res 1,(iy+dd)
            break;
        }

        case 0x8F: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x90: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x91: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x92: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x93: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x94: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x95: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x96: { // res 2,(iy+dd)
            break;
        }

        case 0x97: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x98: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x99: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9A: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9B: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9C: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9D: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0x9E: { // res 3,(iy+dd)
            break;
        }

        case 0x9F: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA0: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA1: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA2: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA3: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA4: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA5: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA6: { // res 4,(iy+dd)
            break;
        }

        case 0xA7: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA8: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xA9: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAA: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAB: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAC: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAD: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xAE: { // res 5,(iy+dd)
            break;
        }

        case 0xAF: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB0: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB1: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB2: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB3: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB4: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB5: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB6: { // res 6,(iy+dd)
            break;
        }

        case 0xB7: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB8: { // ld b,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xB9: { // ld c,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBA: { // ld d,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBB: { // ld e,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBC: { // ld h,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBD: { // ld l,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xBE: { // res 7,(iy+dd)
            break;
        }

        case 0xBF: { // ld a,res
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC6: { // set 0,(iy+dd)
            break;
        }

        case 0xC7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xC9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xCE: { // set 1,(iy+dd)
            break;
        }

        case 0xCF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD6: { // set 2,(iy+dd)
            break;
        }

        case 0xD7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xD9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xDE: { // set 3,(iy+dd)
            break;
        }

        case 0xDF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE6: { // set 4,(iy+dd)
            break;
        }

        case 0xE7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xE9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xED: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xEE: { // set 5,(iy+dd)
            break;
        }

        case 0xEF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF0: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF1: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF2: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF3: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF4: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF5: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF6: { // set 6,(iy+dd)
            break;
        }

        case 0xF7: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF8: { // ld b,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xF9: { // ld c,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFA: { // ld d,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFB: { // ld e,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFC: { // ld h,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFD: { // ld l,set
            // We don't yet implement undocumented opcodes
            break;
        }

        case 0xFE: { // set 7,(iy+dd)
            break;
        }

        case 0xFF: { // ld a,set
            // We don't yet implement undocumented opcodes
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}

export function decode(z80: Z80): void {
    const inst = fetchInstruction(z80);

    switch (inst) {
        
        // The content of this switch is auto-generated by GenerateOpcodes.ts.

        case 0x00: { // nop
            break;
        }

        case 0x01: { // ld bc,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.bc = value;
            break;
        }

        case 0x02: { // ld (bc),a
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.bc));
            z80.writeByte(z80.regs.bc, value);
            break;
        }

        case 0x03: { // inc bc
            break;
        }

        case 0x04: { // inc b
            break;
        }

        case 0x05: { // dec b
            break;
        }

        case 0x06: { // ld b,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.b = value;
            break;
        }

        case 0x07: { // rlca
            break;
        }

        case 0x08: { // ex af,af'
            const rightValue = z80.regs.afPrime;
            z80.regs.afPrime = z80.regs.af;
            z80.regs.af = rightValue;
            break;
        }

        case 0x09: { // add hl,bc
            break;
        }

        case 0x0A: { // ld a,(bc)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.bc);
            value = z80.readByte(z80.regs.bc);
            z80.regs.a = value;
            break;
        }

        case 0x0B: { // dec bc
            break;
        }

        case 0x0C: { // inc c
            break;
        }

        case 0x0D: { // dec c
            break;
        }

        case 0x0E: { // ld c,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.c = value;
            break;
        }

        case 0x0F: { // rrca
            break;
        }

        case 0x10: { // djnz offset
            break;
        }

        case 0x11: { // ld de,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.de = value;
            break;
        }

        case 0x12: { // ld (de),a
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.de));
            z80.writeByte(z80.regs.de, value);
            break;
        }

        case 0x13: { // inc de
            break;
        }

        case 0x14: { // inc d
            break;
        }

        case 0x15: { // dec d
            break;
        }

        case 0x16: { // ld d,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.d = value;
            break;
        }

        case 0x17: { // rla
            break;
        }

        case 0x18: { // jr offset
            break;
        }

        case 0x19: { // add hl,de
            break;
        }

        case 0x1A: { // ld a,(de)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.de);
            value = z80.readByte(z80.regs.de);
            z80.regs.a = value;
            break;
        }

        case 0x1B: { // dec de
            break;
        }

        case 0x1C: { // inc e
            break;
        }

        case 0x1D: { // dec e
            break;
        }

        case 0x1E: { // ld e,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.e = value;
            break;
        }

        case 0x1F: { // rra
            break;
        }

        case 0x20: { // jr nz,offset
            break;
        }

        case 0x21: { // ld hl,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.hl = value;
            break;
        }

        case 0x22: { // ld (nnnn),hl
            let value: number;
            value = z80.regs.hl;
            let addr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            addr = word(z80.readByte(z80.regs.pc), addr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(addr, lo(value));
            z80.regs.memptr = addr;
            z80.writeByte(inc16(addr), hi(value));
            break;
        }

        case 0x23: { // inc hl
            break;
        }

        case 0x24: { // inc h
            break;
        }

        case 0x25: { // dec h
            break;
        }

        case 0x26: { // ld h,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.h = value;
            break;
        }

        case 0x27: { // daa
            break;
        }

        case 0x28: { // jr z,offset
            break;
        }

        case 0x29: { // add hl,hl
            break;
        }

        case 0x2A: { // ld hl,(nnnn)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(value);
            z80.regs.memptr = inc16(value);
            z80.regs.hl = value;
            break;
        }

        case 0x2B: { // dec hl
            break;
        }

        case 0x2C: { // inc l
            break;
        }

        case 0x2D: { // dec l
            break;
        }

        case 0x2E: { // ld l,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.l = value;
            break;
        }

        case 0x2F: { // cpl
            break;
        }

        case 0x30: { // jr nc,offset
            break;
        }

        case 0x31: { // ld sp,nnnn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.sp = value;
            break;
        }

        case 0x32: { // ld (nnnn),a
            let value: number;
            value = z80.regs.a;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(value));
            z80.writeByte(value, z80.regs.a);
            break;
        }

        case 0x33: { // inc sp
            break;
        }

        case 0x34: { // inc (hl)
            break;
        }

        case 0x35: { // dec (hl)
            break;
        }

        case 0x36: { // ld (hl),nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x37: { // scf
            break;
        }

        case 0x38: { // jr c,offset
            break;
        }

        case 0x39: { // add hl,sp
            break;
        }

        case 0x3A: { // ld a,(nnnn)
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            value = word(z80.readByte(z80.regs.pc), value);
            z80.regs.pc = inc16(z80.regs.pc);
            value = z80.readByte(value);
            z80.regs.memptr = inc16(value);
            z80.regs.a = value;
            break;
        }

        case 0x3B: { // dec sp
            break;
        }

        case 0x3C: { // inc a
            break;
        }

        case 0x3D: { // dec a
            break;
        }

        case 0x3E: { // ld a,nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.a = value;
            break;
        }

        case 0x3F: { // ccf
            break;
        }

        case 0x40: { // ld b,b
            let value: number;
            value = z80.regs.b;
            z80.regs.b = value;
            break;
        }

        case 0x41: { // ld b,c
            let value: number;
            value = z80.regs.c;
            z80.regs.b = value;
            break;
        }

        case 0x42: { // ld b,d
            let value: number;
            value = z80.regs.d;
            z80.regs.b = value;
            break;
        }

        case 0x43: { // ld b,e
            let value: number;
            value = z80.regs.e;
            z80.regs.b = value;
            break;
        }

        case 0x44: { // ld b,h
            let value: number;
            value = z80.regs.h;
            z80.regs.b = value;
            break;
        }

        case 0x45: { // ld b,l
            let value: number;
            value = z80.regs.l;
            z80.regs.b = value;
            break;
        }

        case 0x46: { // ld b,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.b = value;
            break;
        }

        case 0x47: { // ld b,a
            let value: number;
            value = z80.regs.a;
            z80.regs.b = value;
            break;
        }

        case 0x48: { // ld c,b
            let value: number;
            value = z80.regs.b;
            z80.regs.c = value;
            break;
        }

        case 0x49: { // ld c,c
            let value: number;
            value = z80.regs.c;
            z80.regs.c = value;
            break;
        }

        case 0x4A: { // ld c,d
            let value: number;
            value = z80.regs.d;
            z80.regs.c = value;
            break;
        }

        case 0x4B: { // ld c,e
            let value: number;
            value = z80.regs.e;
            z80.regs.c = value;
            break;
        }

        case 0x4C: { // ld c,h
            let value: number;
            value = z80.regs.h;
            z80.regs.c = value;
            break;
        }

        case 0x4D: { // ld c,l
            let value: number;
            value = z80.regs.l;
            z80.regs.c = value;
            break;
        }

        case 0x4E: { // ld c,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.c = value;
            break;
        }

        case 0x4F: { // ld c,a
            let value: number;
            value = z80.regs.a;
            z80.regs.c = value;
            break;
        }

        case 0x50: { // ld d,b
            let value: number;
            value = z80.regs.b;
            z80.regs.d = value;
            break;
        }

        case 0x51: { // ld d,c
            let value: number;
            value = z80.regs.c;
            z80.regs.d = value;
            break;
        }

        case 0x52: { // ld d,d
            let value: number;
            value = z80.regs.d;
            z80.regs.d = value;
            break;
        }

        case 0x53: { // ld d,e
            let value: number;
            value = z80.regs.e;
            z80.regs.d = value;
            break;
        }

        case 0x54: { // ld d,h
            let value: number;
            value = z80.regs.h;
            z80.regs.d = value;
            break;
        }

        case 0x55: { // ld d,l
            let value: number;
            value = z80.regs.l;
            z80.regs.d = value;
            break;
        }

        case 0x56: { // ld d,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.d = value;
            break;
        }

        case 0x57: { // ld d,a
            let value: number;
            value = z80.regs.a;
            z80.regs.d = value;
            break;
        }

        case 0x58: { // ld e,b
            let value: number;
            value = z80.regs.b;
            z80.regs.e = value;
            break;
        }

        case 0x59: { // ld e,c
            let value: number;
            value = z80.regs.c;
            z80.regs.e = value;
            break;
        }

        case 0x5A: { // ld e,d
            let value: number;
            value = z80.regs.d;
            z80.regs.e = value;
            break;
        }

        case 0x5B: { // ld e,e
            let value: number;
            value = z80.regs.e;
            z80.regs.e = value;
            break;
        }

        case 0x5C: { // ld e,h
            let value: number;
            value = z80.regs.h;
            z80.regs.e = value;
            break;
        }

        case 0x5D: { // ld e,l
            let value: number;
            value = z80.regs.l;
            z80.regs.e = value;
            break;
        }

        case 0x5E: { // ld e,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.e = value;
            break;
        }

        case 0x5F: { // ld e,a
            let value: number;
            value = z80.regs.a;
            z80.regs.e = value;
            break;
        }

        case 0x60: { // ld h,b
            let value: number;
            value = z80.regs.b;
            z80.regs.h = value;
            break;
        }

        case 0x61: { // ld h,c
            let value: number;
            value = z80.regs.c;
            z80.regs.h = value;
            break;
        }

        case 0x62: { // ld h,d
            let value: number;
            value = z80.regs.d;
            z80.regs.h = value;
            break;
        }

        case 0x63: { // ld h,e
            let value: number;
            value = z80.regs.e;
            z80.regs.h = value;
            break;
        }

        case 0x64: { // ld h,h
            let value: number;
            value = z80.regs.h;
            z80.regs.h = value;
            break;
        }

        case 0x65: { // ld h,l
            let value: number;
            value = z80.regs.l;
            z80.regs.h = value;
            break;
        }

        case 0x66: { // ld h,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.h = value;
            break;
        }

        case 0x67: { // ld h,a
            let value: number;
            value = z80.regs.a;
            z80.regs.h = value;
            break;
        }

        case 0x68: { // ld l,b
            let value: number;
            value = z80.regs.b;
            z80.regs.l = value;
            break;
        }

        case 0x69: { // ld l,c
            let value: number;
            value = z80.regs.c;
            z80.regs.l = value;
            break;
        }

        case 0x6A: { // ld l,d
            let value: number;
            value = z80.regs.d;
            z80.regs.l = value;
            break;
        }

        case 0x6B: { // ld l,e
            let value: number;
            value = z80.regs.e;
            z80.regs.l = value;
            break;
        }

        case 0x6C: { // ld l,h
            let value: number;
            value = z80.regs.h;
            z80.regs.l = value;
            break;
        }

        case 0x6D: { // ld l,l
            let value: number;
            value = z80.regs.l;
            z80.regs.l = value;
            break;
        }

        case 0x6E: { // ld l,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.l = value;
            break;
        }

        case 0x6F: { // ld l,a
            let value: number;
            value = z80.regs.a;
            z80.regs.l = value;
            break;
        }

        case 0x70: { // ld (hl),b
            let value: number;
            value = z80.regs.b;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x71: { // ld (hl),c
            let value: number;
            value = z80.regs.c;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x72: { // ld (hl),d
            let value: number;
            value = z80.regs.d;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x73: { // ld (hl),e
            let value: number;
            value = z80.regs.e;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x74: { // ld (hl),h
            let value: number;
            value = z80.regs.h;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x75: { // ld (hl),l
            let value: number;
            value = z80.regs.l;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x76: { // halt
            break;
        }

        case 0x77: { // ld (hl),a
            let value: number;
            value = z80.regs.a;
            z80.regs.memptr = word(z80.regs.a, inc16(z80.regs.hl));
            z80.writeByte(z80.regs.hl, value);
            break;
        }

        case 0x78: { // ld a,b
            let value: number;
            value = z80.regs.b;
            z80.regs.a = value;
            break;
        }

        case 0x79: { // ld a,c
            let value: number;
            value = z80.regs.c;
            z80.regs.a = value;
            break;
        }

        case 0x7A: { // ld a,d
            let value: number;
            value = z80.regs.d;
            z80.regs.a = value;
            break;
        }

        case 0x7B: { // ld a,e
            let value: number;
            value = z80.regs.e;
            z80.regs.a = value;
            break;
        }

        case 0x7C: { // ld a,h
            let value: number;
            value = z80.regs.h;
            z80.regs.a = value;
            break;
        }

        case 0x7D: { // ld a,l
            let value: number;
            value = z80.regs.l;
            z80.regs.a = value;
            break;
        }

        case 0x7E: { // ld a,(hl)
            let value: number;
            z80.regs.memptr = inc16(z80.regs.hl);
            value = z80.readByte(z80.regs.hl);
            z80.regs.a = value;
            break;
        }

        case 0x7F: { // ld a,a
            let value: number;
            value = z80.regs.a;
            z80.regs.a = value;
            break;
        }

        case 0x80: { // add a,b
            break;
        }

        case 0x81: { // add a,c
            break;
        }

        case 0x82: { // add a,d
            break;
        }

        case 0x83: { // add a,e
            break;
        }

        case 0x84: { // add a,h
            break;
        }

        case 0x85: { // add a,l
            break;
        }

        case 0x86: { // add a,(hl)
            break;
        }

        case 0x87: { // add a,a
            break;
        }

        case 0x88: { // adc a,b
            break;
        }

        case 0x89: { // adc a,c
            break;
        }

        case 0x8A: { // adc a,d
            break;
        }

        case 0x8B: { // adc a,e
            break;
        }

        case 0x8C: { // adc a,h
            break;
        }

        case 0x8D: { // adc a,l
            break;
        }

        case 0x8E: { // adc a,(hl)
            break;
        }

        case 0x8F: { // adc a,a
            break;
        }

        case 0x90: { // sub a,b
            break;
        }

        case 0x91: { // sub a,c
            break;
        }

        case 0x92: { // sub a,d
            break;
        }

        case 0x93: { // sub a,e
            break;
        }

        case 0x94: { // sub a,h
            break;
        }

        case 0x95: { // sub a,l
            break;
        }

        case 0x96: { // sub a,(hl)
            break;
        }

        case 0x97: { // sub a,a
            break;
        }

        case 0x98: { // sbc a,b
            break;
        }

        case 0x99: { // sbc a,c
            break;
        }

        case 0x9A: { // sbc a,d
            break;
        }

        case 0x9B: { // sbc a,e
            break;
        }

        case 0x9C: { // sbc a,h
            break;
        }

        case 0x9D: { // sbc a,l
            break;
        }

        case 0x9E: { // sbc a,(hl)
            break;
        }

        case 0x9F: { // sbc a,a
            break;
        }

        case 0xA0: { // and a,b
            break;
        }

        case 0xA1: { // and a,c
            break;
        }

        case 0xA2: { // and a,d
            break;
        }

        case 0xA3: { // and a,e
            break;
        }

        case 0xA4: { // and a,h
            break;
        }

        case 0xA5: { // and a,l
            break;
        }

        case 0xA6: { // and a,(hl)
            break;
        }

        case 0xA7: { // and a,a
            break;
        }

        case 0xA8: { // xor a,b
            break;
        }

        case 0xA9: { // xor a,c
            break;
        }

        case 0xAA: { // xor a,d
            break;
        }

        case 0xAB: { // xor a,e
            break;
        }

        case 0xAC: { // xor a,h
            break;
        }

        case 0xAD: { // xor a,l
            break;
        }

        case 0xAE: { // xor a,(hl)
            break;
        }

        case 0xAF: { // xor a,a
            break;
        }

        case 0xB0: { // or a,b
            break;
        }

        case 0xB1: { // or a,c
            break;
        }

        case 0xB2: { // or a,d
            break;
        }

        case 0xB3: { // or a,e
            break;
        }

        case 0xB4: { // or a,h
            break;
        }

        case 0xB5: { // or a,l
            break;
        }

        case 0xB6: { // or a,(hl)
            break;
        }

        case 0xB7: { // or a,a
            break;
        }

        case 0xB8: { // cp b
            let value: number;
            value = z80.regs.b;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xB9: { // cp c
            let value: number;
            value = z80.regs.c;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBA: { // cp d
            let value: number;
            value = z80.regs.d;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBB: { // cp e
            let value: number;
            value = z80.regs.e;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBC: { // cp h
            let value: number;
            value = z80.regs.h;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBD: { // cp l
            let value: number;
            value = z80.regs.l;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBE: { // cp (hl)
            let value: number;
            value = z80.readByte(z80.regs.hl);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xBF: { // cp a
            let value: number;
            value = z80.regs.a;
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xC0: { // ret nz
            break;
        }

        case 0xC1: { // pop bc
            z80.regs.bc = z80.popWord();
            break;
        }

        case 0xC2: { // jp nz,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.Z) === 0) {
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xC3: { // jp nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            break;
        }

        case 0xC4: { // call nz,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.Z) === 0) {
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xC5: { // push bc
            z80.pushWord(z80.regs.bc);
            break;
        }

        case 0xC6: { // add a,nn
            break;
        }

        case 0xC7: { // rst 00
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0000;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xC8: { // ret z
            break;
        }

        case 0xC9: { // ret
            break;
        }

        case 0xCA: { // jp z,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.Z) !== 0) {
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xCB: { // shift cb
            decodeCB(z80);
            break;
        }

        case 0xCC: { // call z,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.Z) !== 0) {
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xCD: { // call nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            break;
        }

        case 0xCE: { // adc a,nn
            break;
        }

        case 0xCF: { // rst 8
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0008;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xD0: { // ret nc
            break;
        }

        case 0xD1: { // pop de
            z80.regs.de = z80.popWord();
            break;
        }

        case 0xD2: { // jp nc,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.C) === 0) {
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xD3: { // out (nn),a
            break;
        }

        case 0xD4: { // call nc,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.C) === 0) {
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xD5: { // push de
            z80.pushWord(z80.regs.de);
            break;
        }

        case 0xD6: { // sub nn
            break;
        }

        case 0xD7: { // rst 10
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0010;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xD8: { // ret c
            break;
        }

        case 0xD9: { // exx
            break;
        }

        case 0xDA: { // jp c,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.C) !== 0) {
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xDB: { // in a,(nn)
            break;
        }

        case 0xDC: { // call c,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.C) !== 0) {
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xDD: { // shift dd
            decodeDD(z80);
            break;
        }

        case 0xDE: { // sbc a,nn
            break;
        }

        case 0xDF: { // rst 18
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0018;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xE0: { // ret po
            break;
        }

        case 0xE1: { // pop hl
            z80.regs.hl = z80.popWord();
            break;
        }

        case 0xE2: { // jp po,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.P) === 0) {
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xE3: { // ex (sp),hl
            const rightValue = z80.regs.hl;
            const leftValueL = z80.readByte(z80.regs.sp);
            const leftValueH = z80.readByte(inc16(z80.regs.sp));
            z80.tStateCount += 1;
            z80.writeByte(inc16(z80.regs.sp), hi(rightValue));
            z80.writeByte(z80.regs.sp, lo(rightValue));
            z80.tStateCount += 2;
            z80.regs.memptr = word(leftValueH, leftValueL);
            z80.regs.hl = word(leftValueH, leftValueL);
            break;
        }

        case 0xE4: { // call po,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.P) === 0) {
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xE5: { // push hl
            z80.pushWord(z80.regs.hl);
            break;
        }

        case 0xE6: { // and nn
            break;
        }

        case 0xE7: { // rst 20
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0020;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xE8: { // ret pe
            break;
        }

        case 0xE9: { // jp hl
            z80.regs.pc = z80.regs.hl;
            break;
        }

        case 0xEA: { // jp pe,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.P) !== 0) {
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xEB: { // ex de,hl
            const rightValue = z80.regs.hl;
            z80.regs.hl = z80.regs.de;
            z80.regs.de = rightValue;
            break;
        }

        case 0xEC: { // call pe,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.P) !== 0) {
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xED: { // shift ed
            decodeED(z80);
            break;
        }

        case 0xEE: { // xor a,nn
            break;
        }

        case 0xEF: { // rst 28
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0028;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xF0: { // ret p
            break;
        }

        case 0xF1: { // pop af
            z80.regs.af = z80.popWord();
            break;
        }

        case 0xF2: { // jp p,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.S) === 0) {
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xF3: { // di
            z80.regs.iff1 = 0;
            z80.regs.iff2 = 0;
            break;
        }

        case 0xF4: { // call p,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.S) === 0) {
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xF5: { // push af
            z80.pushWord(z80.regs.af);
            break;
        }

        case 0xF6: { // or nn
            break;
        }

        case 0xF7: { // rst 30
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0030;
            z80.regs.memptr = z80.regs.pc;
            break;
        }

        case 0xF8: { // ret m
            break;
        }

        case 0xF9: { // ld sp,hl
            let value: number;
            value = z80.regs.hl;
            z80.regs.sp = value;
            break;
        }

        case 0xFA: { // jp m,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.S) !== 0) {
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xFB: { // ei
            z80.regs.iff1 = 1;
            z80.regs.iff2 = 1;
            break;
        }

        case 0xFC: { // call m,nnnn
            z80.regs.memptr = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            z80.regs.memptr = word(z80.readByte(z80.regs.pc), z80.regs.memptr);
            z80.regs.pc = inc16(z80.regs.pc);
            if ((z80.regs.f & Flag.S) !== 0) {
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = z80.regs.memptr;
            }
            break;
        }

        case 0xFD: { // shift fd
            decodeFD(z80);
            break;
        }

        case 0xFE: { // cp nn
            let value: number;
            value = z80.readByte(z80.regs.pc);
            z80.regs.pc = inc16(z80.regs.pc);
            const diff = (z80.regs.a - value) & 0xFFFF;
            const lookup = (((z80.regs.a & 0x88) >> 3) |
                           ((value & 0x88) >> 2) |
                           ((diff & 0x88) >> 1)) & 0xFF;
            let f = Flag.N;
            if ((diff & 0x100) != 0) f |= Flag.C;
            if (diff == 0) f |= Flag.Z;
            f |= halfCarrySubTable[lookup & 0x07];
            f |= overflowSubTable[lookup >> 4];
            f |= value & (Flag.X3 | Flag.X5);
            f |= diff & Flag.S;
            z80.regs.af = word(z80.regs.a, f);
            break;
        }

        case 0xFF: { // rst 38
            z80.tStateCount += 1;
            z80.pushWord(z80.regs.pc);
            z80.regs.pc = 0x0038;
            z80.regs.memptr = z80.regs.pc;
            break;
        }


        default:
            console.log("Unhandled opcode " + toHex(inst, 2));
            break;

    }
}
